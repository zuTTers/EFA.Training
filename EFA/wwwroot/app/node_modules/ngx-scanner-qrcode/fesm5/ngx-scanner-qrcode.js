import { AsyncSubject, BehaviorSubject } from 'rxjs';
import { __awaiter, __generator, __extends, __assign, __spread } from 'tslib';
import { Injectable, NgModule, EventEmitter, Component, ViewChild, ViewEncapsulation, defineInjectable } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var MEDIA_STREAM_DEFAULT = {
    audio: false,
    video: true
};
/** @type {?} */
var CONFIG_DEFAULT = {
    src: '',
    fps: 30,
    vibrate: 300,
    decode: 'utf-8',
    isBeep: true,
    deviceActive: 0,
    constraints: MEDIA_STREAM_DEFAULT,
};

var _this = this;
/**
 * OVERRIDES
 * \@param variableKey
 * \@param config
 * \@param defaultConfig
 * \@return
 * @type {?}
 */
var OVERRIDES = (/**
 * @param {?} variableKey
 * @param {?} config
 * @param {?} defaultConfig
 * @return {?}
 */
function (variableKey, config, defaultConfig) {
    var _a;
    if (config && Object.keys(config[variableKey]).length) {
        for (var key in defaultConfig) {
            /** @type {?} */
            var cloneDeep = JSON.parse(JSON.stringify(__assign({}, config[variableKey], (_a = {}, _a[key] = ((/** @type {?} */ (defaultConfig)))[key], _a))));
            config[variableKey] = config[variableKey].hasOwnProperty(key) ? config[variableKey] : cloneDeep;
        }
        return config[variableKey];
    }
    else {
        return defaultConfig;
    }
});
/**
 * Rxjs complete
 * \@param as
 * \@param data
 * \@param error
 * @type {?}
 */
var AS_COMPLETE = (/**
 * @param {?} as
 * @param {?} data
 * @param {?=} error
 * @return {?}
 */
function (as, data, error) {
    if (error === void 0) { error = null; }
    error ? as.error(error) : as.next(data);
    as.complete();
});
/**
 * CAMERA_BEEP
 * \@param isPlay
 * \@return
 * @type {?}
 */
var PLAY_AUDIO = (/**
 * @param {?=} isPlay
 * @return {?}
 */
function (isPlay) {
    if (isPlay === void 0) { isPlay = false; }
    if (isPlay === false)
        return;
    /** @type {?} */
    var audio = new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU' + Array(300).join('101'));
    // when the sound has been loaded, execute your code
    audio.oncanplaythrough = (/**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var promise = audio.play();
        if (promise) {
            promise.catch((/**
             * @param {?} e
             * @return {?}
             */
            function (e) {
                if (e.name === "NotAllowedError" || e.name === "NotSupportedError") ;
            }));
        }
    });
});
/**
 * HAS_OWN_PROPERTY
 * Fix issue vs ng v 6-7-8
 * Optional chaining (?.) just have on ng v 9++
 * eg: HAS_OWN_PROPERTY(config, 'frameOptions.style') // output: boolean
 * \@param obj
 * \@param propertyPath
 * \@return
 * @type {?}
 */
var HAS_OWN_PROPERTY = (/**
 * @param {?} obj
 * @param {?} propertyPath
 * @return {?}
 */
function (obj, propertyPath) {
    /** @type {?} */
    var properties = propertyPath.split(".");
    for (var i = 0; i < properties.length; i++) {
        /** @type {?} */
        var prop = properties[i];
        if (!obj.hasOwnProperty(prop)) {
            return false;
        }
        else {
            obj = obj[prop];
        }
    }
    return true;
});
/**
 * DRAW_RESULT_APPEND_CHILD
 * \@param code
 * \@param oriCanvas
 * \@param elTarget
 * @type {?}
 */
var DRAW_RESULT_APPEND_CHILD = (/**
 * @param {?} code
 * @param {?} oriCanvas
 * @param {?} elTarget
 * @return {?}
 */
function (code, oriCanvas, elTarget) {
    /** @type {?} */
    var widthZoom;
    /** @type {?} */
    var heightZoom;
    /** @type {?} */
    var oriWidth = oriCanvas.width;
    /** @type {?} */
    var oriHeight = oriCanvas.height;
    /** @type {?} */
    var oriWHRatio = oriWidth / oriHeight;
    /** @type {?} */
    var imgWidth = parseInt(getComputedStyle(oriCanvas).width);
    /** @type {?} */
    var imgHeight = parseInt(getComputedStyle(oriCanvas).height);
    /** @type {?} */
    var imgWHRatio = imgWidth / imgHeight;
    elTarget.innerHTML = '';
    if (oriWHRatio > imgWHRatio) {
        widthZoom = imgWidth / oriWidth;
        heightZoom = imgWidth / oriWHRatio / oriHeight;
    }
    else {
        heightZoom = imgHeight / oriHeight;
        widthZoom = (imgHeight * oriWHRatio) / oriWidth;
    }
    for (var i = 0; i < code.length; i++) {
        /** @type {?} */
        var _code = code[i];
        // New canvas
        /** @type {?} */
        var cvs = document.createElement("canvas");
        /** @type {?} */
        var ctx = (/** @type {?} */ (cvs.getContext('2d', { willReadFrequently: true })));
        /** @type {?} */
        var loc = {};
        /** @type {?} */
        var X = [];
        /** @type {?} */
        var Y = [];
        // Point x,y
        /** @type {?} */
        var points = _code.points;
        for (var j = 0; j < points.length; j++) {
            /** @type {?} */
            var xj = HAS_OWN_PROPERTY(points, j + ".x") ? points[j].x : 0;
            /** @type {?} */
            var yj = HAS_OWN_PROPERTY(points, j + ".y") ? points[j].y : 0;
            loc["x" + (j + 1)] = xj;
            loc["y" + (j + 1)] = yj;
            X.push(xj);
            Y.push(yj);
        }
        // Min max
        /** @type {?} */
        var maxX = Math.max.apply(Math, __spread(X));
        /** @type {?} */
        var minX = Math.min.apply(Math, __spread(X));
        /** @type {?} */
        var maxY = Math.max.apply(Math, __spread(Y));
        /** @type {?} */
        var minY = Math.min.apply(Math, __spread(Y));
        // Add class
        cvs.setAttribute('class', 'qrcode-polygon');
        // Size with screen zoom
        if (oriWHRatio > imgWHRatio) {
            cvs.style.top = minY * heightZoom + (imgHeight - imgWidth / oriWHRatio) * 0.5 + "px";
            cvs.style.left = minX * widthZoom + "px";
            cvs.width = (maxX - minX) * widthZoom;
            cvs.height = (maxY - minY) * widthZoom;
        }
        else {
            cvs.style.top = minY * heightZoom + "px";
            cvs.style.left = minX * widthZoom + (imgWidth - imgHeight * oriWHRatio) * 0.5 + "px";
            cvs.width = (maxX - minX) * heightZoom;
            cvs.height = (maxY - minY) * heightZoom;
        }
        // Style for canvas
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'green';
        ctx.fillStyle = "#55f02880";
        // polygon [x,y, x,y, x,y.....];
        /** @type {?} */
        var polygon = [];
        for (var k = 0; k < X.length; k++) {
            polygon.push((loc["x" + (k + 1)] - minX) * heightZoom);
            polygon.push((loc["y" + (k + 1)] - minY) * widthZoom);
        }
        // Copy array
        /** @type {?} */
        var shape = (/** @type {?} */ (polygon.slice(0)));
        // Draw polygon
        ctx.beginPath();
        ctx.moveTo(shape.shift(), shape.shift());
        while (shape.length) {
            ctx.lineTo(shape.shift(), shape.shift()); //x,y
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        // Tooltip result
        /** @type {?} */
        var qrcodeTooltipTemp = document.createElement('div');
        qrcodeTooltipTemp.setAttribute('class', 'qrcode-tooltip-temp');
        qrcodeTooltipTemp.innerText = _code.value;
        // Tooltip box
        /** @type {?} */
        var qrcodeTooltip = document.createElement('div');
        qrcodeTooltip.setAttribute('class', 'qrcode-tooltip');
        qrcodeTooltip.appendChild(qrcodeTooltipTemp);
        heightZoom = imgHeight / oriHeight;
        widthZoom = (imgHeight * oriWHRatio) / oriWidth;
        qrcodeTooltip.style.fontSize = widthZoom * 15 + 'px';
        qrcodeTooltip.style.top = minY * heightZoom + "px";
        qrcodeTooltip.style.left = minX * widthZoom + (imgWidth - imgHeight * oriWHRatio) * 0.5 + "px";
        qrcodeTooltip.style.width = (maxX - minX) * heightZoom + "px";
        qrcodeTooltip.style.height = (maxY - minY) * heightZoom + "px";
        // Result text
        /** @type {?} */
        var resultText = document.createElement('span');
        resultText.innerText = _code.value;
        resultText.style.fontSize = widthZoom * 13 + 'px';
        // Set position result text
        resultText.style.top = minY * heightZoom + (-20 * heightZoom) + "px";
        resultText.style.left = minX * widthZoom + (imgWidth - imgHeight * oriWHRatio) * 0.5 + "px";
        if (elTarget) {
            elTarget.appendChild(qrcodeTooltip);
            elTarget.appendChild(resultText);
            elTarget.appendChild(cvs);
        }
    }
})
/**
 * DRAW_RESULT_ON_CANVAS
 * @param code
 * @param cvs
 */
;
/**
 * DRAW_RESULT_ON_CANVAS
 * \@param code
 * \@param cvs
 * @type {?}
 */
var DRAW_RESULT_ON_CANVAS = (/**
 * @param {?} code
 * @param {?} cvs
 * @return {?}
 */
function (code, cvs) {
    /** @type {?} */
    var ctx = (/** @type {?} */ (cvs.getContext('2d', { willReadFrequently: true })));
    for (var i = 0; i < code.length; i++) {
        /** @type {?} */
        var _code = code[i];
        /** @type {?} */
        var loc = {};
        /** @type {?} */
        var X = [];
        /** @type {?} */
        var Y = [];
        // Point x,y
        /** @type {?} */
        var points = _code.points;
        for (var j = 0; j < points.length; j++) {
            /** @type {?} */
            var xj = HAS_OWN_PROPERTY(points, j + ".x") ? points[j].x : 0;
            /** @type {?} */
            var yj = HAS_OWN_PROPERTY(points, j + ".y") ? points[j].y : 0;
            loc["x" + (j + 1)] = xj;
            loc["y" + (j + 1)] = yj;
            X.push(xj);
            Y.push(yj);
        }
        // Min max
        /** @type {?} */
        var minX = Math.min.apply(Math, __spread(X));
        /** @type {?} */
        var minY = Math.min.apply(Math, __spread(Y));
        // Style for canvas
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'green';
        ctx.fillStyle = "#55f02880";
        ctx.font = "15px serif";
        FILL_TEXT_MULTI_LINE(ctx, _code.value, minX, minY - 5);
        // polygon [x,y, x,y, x,y.....];
        /** @type {?} */
        var polygon = [];
        for (var k = 0; k < X.length; k++) {
            polygon.push(loc["x" + (k + 1)]);
            polygon.push(loc["y" + (k + 1)]);
        }
        // Copy array
        /** @type {?} */
        var shape = (/** @type {?} */ (polygon.slice(0)));
        // Draw polygon
        ctx.beginPath();
        ctx.moveTo(shape.shift(), shape.shift());
        while (shape.length) {
            ctx.lineTo(shape.shift(), shape.shift()); //x,y
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }
})
/**
 * READ_AS_DATA_URL
 * @param file
 * @param config
 * @return Promise
 */
;
/**
 * READ_AS_DATA_URL
 * \@param file
 * \@param config
 * \@return Promise
 * @type {?}
 */
var READ_AS_DATA_URL = (/**
 * @param {?} file
 * @param {?} config
 * @return {?}
 */
function (file, config) {
    /**
     * overrides *
     * @type {?}
     */
    var decode = HAS_OWN_PROPERTY(config, 'decode') ? config.decode : CONFIG_DEFAULT.decode;
    /** drawImage **/
    return new Promise((/**
     * @param {?} resolve
     * @param {?} reject
     * @return {?}
     */
    function (resolve, reject) {
        /** @type {?} */
        var fileReader = new FileReader();
        fileReader.onload = (/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var objectFile = {
                name: file.name,
                file: file,
                url: URL.createObjectURL(file)
            };
            // Set the src of this Image object.
            /** @type {?} */
            var image = new Image();
            // Setting cross origin value to anonymous
            image.setAttribute('crossOrigin', 'anonymous');
            // When our image has loaded.
            image.onload = (/**
             * @return {?}
             */
            function () { return __awaiter(_this, void 0, void 0, function () {
                var canvas, ctx, imageData, code, blob, url, blobToFile;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // Get the canvas element by using the getElementById method.
                            canvas = document.createElement('canvas');
                            // HTMLImageElement size
                            canvas.width = image.naturalWidth || image.width;
                            canvas.height = image.naturalHeight || image.height;
                            // Get a 2D drawing context for the canvas.
                            ctx = (/** @type {?} */ (canvas.getContext('2d')));
                            // Draw image
                            ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
                            // Data image
                            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            // Scanner
                            return [4 /*yield*/, zbarWasm.scanImageData(imageData)];
                        case 1:
                            code = _a.sent();
                            if (!(code && code.length)) return [3 /*break*/, 3];
                            // Decode
                            code.forEach((/**
                             * @param {?} s
                             * @return {?}
                             */
                            function (s) { return s.value = s.decode(decode && decode.toLocaleLowerCase()); }));
                            // Overlay
                            DRAW_RESULT_ON_CANVAS(code, canvas);
                            // Emit object
                            return [4 /*yield*/, CANVAS_TO_BLOB(canvas)];
                        case 2:
                            blob = _a.sent();
                            url = URL.createObjectURL(blob);
                            blobToFile = (/**
                             * @param {?} theBlob
                             * @param {?} fileName
                             * @return {?}
                             */
                            function (theBlob, fileName) { return new File([theBlob], fileName, { lastModified: new Date().getTime(), type: theBlob.type }); });
                            resolve(Object.assign({}, objectFile, { data: code, url: url, canvas: canvas, file: blobToFile(blob, objectFile.name) }));
                            return [3 /*break*/, 4];
                        case 3:
                            resolve(Object.assign({}, objectFile, { data: code, canvas: canvas }));
                            _a.label = 4;
                        case 4: return [2 /*return*/];
                    }
                });
            }); });
            // Set src
            image.src = objectFile.url;
        });
        fileReader.onerror = (/**
         * @param {?} error
         * @return {?}
         */
        function (error) { return reject(error); });
        fileReader.readAsDataURL(file);
    }));
})
/**
 * Convert canvas to blob
 * canvas.toBlob((blob) => { .. }, 'image/jpeg', 0.95); // JPEG at 95% quality
 * @param canvas
 * @param type
 * @return Promise
 */
;
/**
 * Convert canvas to blob
 * canvas.toBlob((blob) => { .. }, 'image/jpeg', 0.95); // JPEG at 95% quality
 * \@param canvas
 * \@param type
 * \@return Promise
 * @type {?}
 */
var CANVAS_TO_BLOB = (/**
 * @param {?} canvas
 * @param {?=} type
 * @return {?}
 */
function (canvas, type) {
    return new Promise((/**
     * @param {?} resolve
     * @param {?} reject
     * @return {?}
     */
    function (resolve, reject) { return canvas.toBlob((/**
     * @param {?} blob
     * @return {?}
     */
    function (blob) { return resolve(blob); }), type); }));
})
/**
 * Convert blob to file
 * @param theBlob
 * @param fileName
 * @return File
 */
;
/**
 * Convert blob to file
 * \@param theBlob
 * \@param fileName
 * \@return File
 * @type {?}
 */
var BLOB_TO_FILE = (/**
 * @param {?} theBlob
 * @param {?} fileName
 * @return {?}
 */
function (theBlob, fileName) {
    return new File([theBlob], fileName, { lastModified: new Date().getTime(), type: theBlob.type });
})
/**
 * FILES_TO_SCAN
 * @param files
 * @return AsyncSubject
 */
;
/**
 * FILES_TO_SCAN
 * \@param files
 * \@return AsyncSubject
 * @type {?}
 */
var FILES_TO_SCAN = (/**
 * @param {?=} files
 * @param {?=} configs
 * @param {?=} as
 * @return {?}
 */
function (files, configs, as) {
    if (files === void 0) { files = []; }
    if (as === void 0) { as = new AsyncSubject(); }
    Promise.all(Object.assign([], files).map((/**
     * @param {?} m
     * @return {?}
     */
    function (m) { return READ_AS_DATA_URL(m, configs); }))).then((/**
     * @param {?} img
     * @return {?}
     */
    function (img) { return AS_COMPLETE(as, img); })).catch((/**
     * @param {?} error
     * @return {?}
     */
    function (error) { return AS_COMPLETE(as, null, error); }));
    return as;
})
/**
 * FILL_TEXT_MULTI_LINE
 * @param ctx
 * @param text
 * @param x
 * @param y
 */
;
/**
 * FILL_TEXT_MULTI_LINE
 * \@param ctx
 * \@param text
 * \@param x
 * \@param y
 * @type {?}
 */
var FILL_TEXT_MULTI_LINE = (/**
 * @param {?} ctx
 * @param {?} text
 * @param {?} x
 * @param {?} y
 * @return {?}
 */
function (ctx, text, x, y) {
    /** @type {?} */
    var lineHeight = ctx.measureText("M").width * 1.2;
    /** @type {?} */
    var lines = text.split("\n");
    for (var i = 0; i < lines.length; ++i) {
        ctx.fillText(lines[i], x, y);
        ctx.strokeText(lines[i], x, y);
        y += lineHeight;
    }
})
/**
 * VIBRATE
 * Bật rung trên mobile
 * @param time
 */
;
/**
 * VIBRATE
 * Bật rung trên mobile
 * \@param time
 * @type {?}
 */
var VIBRATE = (/**
 * @param {?} time
 * @return {?}
 */
function (time) {
    time && IS_MOBILE() && window.navigator.vibrate(time);
});
/**
 * IS_MOBILE
 * \@return
 * @type {?}
 */
var IS_MOBILE = (/**
 * @return {?}
 */
function () {
    /** @type {?} */
    var vendor = navigator.userAgent || navigator['vendor'] || window['opera'];
    return !!(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(vendor) ||
        /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(vendor.substr(0, 4)));
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxScannerQrcodeService = /** @class */ (function () {
    function NgxScannerQrcodeService() {
    }
    /**
     * Load files
     * @param files
     * @return AsyncSubject
     */
    /**
     * Load files
     * @param {?=} files
     * @return {?} AsyncSubject
     */
    NgxScannerQrcodeService.prototype.loadFiles = /**
     * Load files
     * @param {?=} files
     * @return {?} AsyncSubject
     */
    function (files) {
        var _this = this;
        if (files === void 0) { files = []; }
        /** @type {?} */
        var as = new AsyncSubject();
        Promise.all(Object.assign([], files).map((/**
         * @param {?} m
         * @return {?}
         */
        function (m) { return _this.readAsDataURL(m); }))).then((/**
         * @param {?} img
         * @return {?}
         */
        function (img) { return AS_COMPLETE(as, img); })).catch((/**
         * @param {?} error
         * @return {?}
         */
        function (error) { return AS_COMPLETE(as, null, error); }));
        return as;
    };
    /**
     * loadFilesToScan
     * @param files
     * @param config
     * @returns
     */
    /**
     * loadFilesToScan
     * @param {?=} files
     * @param {?=} config
     * @return {?}
     */
    NgxScannerQrcodeService.prototype.loadFilesToScan = /**
     * loadFilesToScan
     * @param {?=} files
     * @param {?=} config
     * @return {?}
     */
    function (files, config) {
        if (files === void 0) { files = []; }
        return FILES_TO_SCAN(files, config);
    };
    /**
     * readAsDataURL
     * @param file
     * @return Promise
     */
    /**
     * readAsDataURL
     * @private
     * @param {?} file
     * @return {?} Promise
     */
    NgxScannerQrcodeService.prototype.readAsDataURL = /**
     * readAsDataURL
     * @private
     * @param {?} file
     * @return {?} Promise
     */
    function (file) {
        /** drawImage **/
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        function (resolve, reject) {
            /** @type {?} */
            var fileReader = new FileReader();
            fileReader.onload = (/**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var objectFile = {
                    name: file.name,
                    file: file,
                    url: URL.createObjectURL(file)
                };
                resolve(objectFile);
            });
            fileReader.onerror = (/**
             * @param {?} error
             * @return {?}
             */
            function (error) { return reject(error); });
            fileReader.readAsDataURL(file);
        }));
    };
    NgxScannerQrcodeService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */ NgxScannerQrcodeService.ngInjectableDef = defineInjectable({ factory: function NgxScannerQrcodeService_Factory() { return new NgxScannerQrcodeService(); }, token: NgxScannerQrcodeService, providedIn: "root" });
    return NgxScannerQrcodeService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxScannerQrcodeComponent = /** @class */ (function () {
    function NgxScannerQrcodeComponent() {
        /**
         * EventEmitter
         */
        this.event = new EventEmitter();
        /**
         * Input
         */
        this.src = CONFIG_DEFAULT.src;
        this.fps = CONFIG_DEFAULT.fps;
        this.vibrate = CONFIG_DEFAULT.vibrate;
        this.decode = CONFIG_DEFAULT.decode;
        this.isBeep = CONFIG_DEFAULT.isBeep;
        this.deviceActive = CONFIG_DEFAULT.deviceActive;
        this.config = CONFIG_DEFAULT;
        this.constraints = CONFIG_DEFAULT.constraints;
        /**
         * Export
         */
        this.isStart = false;
        this.isLoading = false;
        this.isTorch = false;
        this.data = new BehaviorSubject([]);
        this.devices = new BehaviorSubject([]);
        this.dataForResize = [];
    }
    /**
     * @return {?}
     */
    NgxScannerQrcodeComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.overrideConfig();
        if (this.src) {
            this.loadImage(this.src);
        }
        this.resize();
    };
    /**
     * start
     * @return AsyncSubject
     */
    /**
     * start
     * @return {?} AsyncSubject
     */
    NgxScannerQrcodeComponent.prototype.start = /**
     * start
     * @return {?} AsyncSubject
     */
    function () {
        /** @type {?} */
        var as = new AsyncSubject();
        if (this.isStart) {
            // Reject
            AS_COMPLETE(as, false);
        }
        else {
            // mediaDevices
            this.loadAllDevices(as);
        }
        return as;
    };
    /**
     * playDevice
     * @param deviceId
     * @param as
     * @return AsyncSubject
     */
    /**
     * playDevice
     * @param {?} deviceId
     * @param {?=} as
     * @return {?} AsyncSubject
     */
    NgxScannerQrcodeComponent.prototype.playDevice = /**
     * playDevice
     * @param {?} deviceId
     * @param {?=} as
     * @return {?} AsyncSubject
     */
    function (deviceId, as) {
        var _this = this;
        if (as === void 0) { as = new AsyncSubject(); }
        /** @type {?} */
        var existDeviceId = this.isStart ? this.getConstraints().deviceId != deviceId : true;
        switch (true) {
            case deviceId == 'null' || deviceId == null:
                this.stop();
                AS_COMPLETE(as, false);
                break;
            case deviceId && existDeviceId:
                stop();
                this.stop();
                clearInterval(this.rAF_ID);
                // Loading on
                this.status(false, true);
                /** @type {?} */
                var constraints = {
                    audio: false,
                    video: (typeof (this.constraints && this.constraints.video) === 'boolean') ? { deviceId: deviceId } : Object.assign({ deviceId: deviceId }, this.constraints && this.constraints.video)
                };
                this.deviceActive = this.devices.value.findIndex((/**
                 * @param {?} f
                 * @return {?}
                 */
                function (f) { return f.deviceId == deviceId; }));
                // MediaStream
                navigator.mediaDevices.getUserMedia(constraints).then((/**
                 * @param {?} stream
                 * @return {?}
                 */
                function (stream) {
                    _this.video.nativeElement.srcObject = stream;
                    _this.video.nativeElement.onloadedmetadata = (/**
                     * @return {?}
                     */
                    function () {
                        _this.video.nativeElement.play();
                        _this.requestAnimationFrame();
                        _this.status(true, false);
                        AS_COMPLETE(as, true);
                    });
                })).catch((/**
                 * @param {?} error
                 * @return {?}
                 */
                function (error) {
                    _this.status(false, false);
                    _this.eventEmit(false);
                    AS_COMPLETE(as, false, error);
                }));
                break;
            default:
                AS_COMPLETE(as, false);
                break;
        }
        return as;
    };
    /**
     * stop
     * @return AsyncSubject
     */
    /**
     * stop
     * @return {?} AsyncSubject
     */
    NgxScannerQrcodeComponent.prototype.stop = /**
     * stop
     * @return {?} AsyncSubject
     */
    function () {
        this.eventEmit(null);
        this.status(false, false);
        /** @type {?} */
        var as = new AsyncSubject();
        try {
            this.removeCanvas();
            clearInterval(this.rAF_ID);
            ((/** @type {?} */ (this.video.nativeElement.srcObject))).getTracks().forEach((/**
             * @param {?} track
             * @return {?}
             */
            function (track) {
                track.stop();
                AS_COMPLETE(as, true);
            }));
        }
        catch (error) {
            AS_COMPLETE(as, false, (/** @type {?} */ (error)));
        }
        return as;
    };
    /**
     * play
     * @return AsyncSubject
     */
    /**
     * play
     * @return {?} AsyncSubject
     */
    NgxScannerQrcodeComponent.prototype.play = /**
     * play
     * @return {?} AsyncSubject
     */
    function () {
        /** @type {?} */
        var as = new AsyncSubject();
        if (this.isPause) {
            this.video.nativeElement.play();
            this.requestAnimationFrame();
            AS_COMPLETE(as, true);
        }
        else {
            AS_COMPLETE(as, false);
        }
        return as;
    };
    /**
     * pause
     * @return AsyncSubject
     */
    /**
     * pause
     * @return {?} AsyncSubject
     */
    NgxScannerQrcodeComponent.prototype.pause = /**
     * pause
     * @return {?} AsyncSubject
     */
    function () {
        /** @type {?} */
        var as = new AsyncSubject();
        if (this.isStart) {
            clearInterval(this.rAF_ID);
            this.video.nativeElement.pause();
            AS_COMPLETE(as, true);
        }
        else {
            AS_COMPLETE(as, false);
        }
        return as;
    };
    /**
     * loadImage
     * @param src
     * @return AsyncSubject
     */
    /**
     * loadImage
     * @param {?} src
     * @return {?} AsyncSubject
     */
    NgxScannerQrcodeComponent.prototype.loadImage = /**
     * loadImage
     * @param {?} src
     * @return {?} AsyncSubject
     */
    function (src) {
        var _this = this;
        /** @type {?} */
        var as = new AsyncSubject();
        // Loading on
        this.status(false, true);
        // Set the src of this Image object.
        /** @type {?} */
        var image = new Image();
        // Setting cross origin value to anonymous
        image.setAttribute('crossOrigin', 'anonymous');
        // When our image has loaded.
        image.onload = (/**
         * @return {?}
         */
        function () {
            _this.drawImage(image, (/**
             * @param {?} flag
             * @return {?}
             */
            function (flag) {
                _this.status(false, false);
                AS_COMPLETE(as, flag);
            }));
        });
        // Set src
        image.src = src;
        return as;
    };
    /**
     * torcher
     * @return AsyncSubject
     */
    /**
     * torcher
     * @return {?} AsyncSubject
     */
    NgxScannerQrcodeComponent.prototype.torcher = /**
     * torcher
     * @return {?} AsyncSubject
     */
    function () {
        var _this = this;
        /** @type {?} */
        var as = this.applyConstraints({ torch: this.isTorch });
        as.subscribe((/**
         * @return {?}
         */
        function () { return false; }), (/**
         * @return {?}
         */
        function () { return _this.isTorch = !_this.isTorch; }));
        return as;
    };
    /**
     * applyConstraints
     * @return AsyncSubject
     */
    /**
     * applyConstraints
     * @param {?} constraints
     * @return {?} AsyncSubject
     */
    NgxScannerQrcodeComponent.prototype.applyConstraints = /**
     * applyConstraints
     * @param {?} constraints
     * @return {?} AsyncSubject
     */
    function (constraints) {
        var _this = this;
        /** @type {?} */
        var as = new AsyncSubject();
        /** @type {?} */
        var stream = (/** @type {?} */ (this.video.nativeElement.srcObject));
        /** @type {?} */
        var videoTrack = (/** @type {?} */ (stream.getVideoTracks()[0]));
        /** @type {?} */
        var imageCapture = new ((/** @type {?} */ (window))).ImageCapture(videoTrack);
        imageCapture.getPhotoCapabilities().then((/**
         * @return {?}
         */
        function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, videoTrack.applyConstraints((/** @type {?} */ ({ advanced: [constraints] })))];
                    case 1:
                        _a.sent();
                        AS_COMPLETE(as, true);
                        return [2 /*return*/];
                }
            });
        }); })).catch((/**
         * @param {?} error
         * @return {?}
         */
        function (error) {
            switch (error && error.name) {
                case 'NotFoundError':
                case 'DevicesNotFoundError':
                    AS_COMPLETE(as, false, (/** @type {?} */ ('Required track is missing')));
                    break;
                case 'NotReadableError':
                case 'TrackStartError':
                    AS_COMPLETE(as, false, (/** @type {?} */ ('Webcam or mic are already in use')));
                    break;
                case 'OverconstrainedError':
                case 'ConstraintNotSatisfiedError':
                    AS_COMPLETE(as, false, (/** @type {?} */ ('Constraints can not be satisfied by avb. devices')));
                    break;
                case 'NotAllowedError':
                case 'PermissionDeniedError':
                    AS_COMPLETE(as, false, (/** @type {?} */ ('Permission denied in browser')));
                    break;
                case 'TypeError':
                    AS_COMPLETE(as, false, (/** @type {?} */ ('Empty constraints object')));
                    break;
                default:
                    AS_COMPLETE(as, false, (/** @type {?} */ (error)));
                    break;
            }
        }));
        return as;
    };
    /**
     * getConstraints
     * @param deviceActive
     * @returns
     */
    /**
     * getConstraints
     * @return {?}
     */
    NgxScannerQrcodeComponent.prototype.getConstraints = /**
     * getConstraints
     * @return {?}
     */
    function () {
        /** @type {?} */
        var stream = (/** @type {?} */ (this.video.nativeElement.srcObject));
        /** @type {?} */
        var videoTrack = stream && (/** @type {?} */ (stream.getVideoTracks()[0]));
        return videoTrack && (/** @type {?} */ (videoTrack.getConstraints()));
    };
    /**
     * download
     * @param fileName
     * @return AsyncSubject
     */
    /**
     * download
     * @param {?=} fileName
     * @return {?} AsyncSubject
     */
    NgxScannerQrcodeComponent.prototype.download = /**
     * download
     * @param {?=} fileName
     * @return {?} AsyncSubject
     */
    function (fileName) {
        var _this = this;
        if (fileName === void 0) { fileName = "ngx-scanner-qrcode-" + Date.now() + ".png"; }
        /** @type {?} */
        var as = new AsyncSubject();
        /** @type {?} */
        var run = (/**
         * @return {?}
         */
        function () { return __awaiter(_this, void 0, void 0, function () {
            var blob, file;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, CANVAS_TO_BLOB(this.canvas.nativeElement)];
                    case 1:
                        blob = _a.sent();
                        file = BLOB_TO_FILE(blob, fileName);
                        FILES_TO_SCAN([file], this.config, as).subscribe((/**
                         * @param {?} res
                         * @return {?}
                         */
                        function (res) {
                            res.forEach((/**
                             * @param {?} item
                             * @return {?}
                             */
                            function (item) {
                                /** @type {?} */
                                var link = document.createElement('a');
                                link.href = item.url;
                                link.download = item.name;
                                link.click();
                                link.remove();
                            }));
                        }));
                        return [2 /*return*/];
                }
            });
        }); });
        run();
        return as;
    };
    /**
     * window: resize
     * Draw again!
     */
    /**
     * window: resize
     * Draw again!
     * @private
     * @return {?}
     */
    NgxScannerQrcodeComponent.prototype.resize = /**
     * window: resize
     * Draw again!
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        window.addEventListener("resize", (/**
         * @return {?}
         */
        function () {
            if (_this.dataForResize && _this.dataForResize.length) {
                DRAW_RESULT_APPEND_CHILD((/** @type {?} */ (_this.dataForResize)), _this.canvas.nativeElement, _this.resultsPanel.nativeElement);
            }
        }));
    };
    /**
     * Override config
     * @return void
     */
    /**
     * Override config
     * @private
     * @return {?} void
     */
    NgxScannerQrcodeComponent.prototype.overrideConfig = /**
     * Override config
     * @private
     * @return {?} void
     */
    function () {
        if (HAS_OWN_PROPERTY(this.config, 'src'))
            this.src = this.config.src;
        if (HAS_OWN_PROPERTY(this.config, 'fps'))
            this.fps = this.config.fps;
        if (HAS_OWN_PROPERTY(this.config, 'vibrate'))
            this.vibrate = this.config.vibrate;
        if (HAS_OWN_PROPERTY(this.config, 'decode'))
            this.decode = this.config.decode;
        if (HAS_OWN_PROPERTY(this.config, 'isBeep'))
            this.isBeep = this.config.isBeep;
        if (HAS_OWN_PROPERTY(this.config, 'deviceActive'))
            this.deviceActive = this.config.deviceActive;
        if (HAS_OWN_PROPERTY(this.config, 'constraints'))
            this.constraints = OVERRIDES('constraints', this.config, MEDIA_STREAM_DEFAULT);
    };
    /**
     * loadAllDevices
     */
    /**
     * loadAllDevices
     * @private
     * @param {?} as
     * @return {?}
     */
    NgxScannerQrcodeComponent.prototype.loadAllDevices = /**
     * loadAllDevices
     * @private
     * @param {?} as
     * @return {?}
     */
    function (as) {
        var _this = this;
        navigator.mediaDevices.enumerateDevices().then((/**
         * @param {?} devices
         * @return {?}
         */
        function (devices) {
            /** @type {?} */
            var cameraDevices = [];
            devices.forEach((/**
             * @param {?} f
             * @return {?}
             */
            function (f) { return f.kind == 'videoinput' && cameraDevices.push(f); }));
            _this.devices.next(cameraDevices);
            if (cameraDevices.length > 0) {
                /** @type {?} */
                var index = Math.max(0, (cameraDevices.length > _this.deviceActive ? _this.deviceActive : 0));
                _this.playDevice(cameraDevices[index].deviceId, as);
            }
            else {
                AS_COMPLETE(as, false, (/** @type {?} */ ('No camera detected.')));
            }
        }));
    };
    /**
     * drawImage
     * @param element
     * @param callback
     */
    /**
     * drawImage
     * @private
     * @param {?} element
     * @param {?=} callback
     * @return {?}
     */
    NgxScannerQrcodeComponent.prototype.drawImage = /**
     * drawImage
     * @private
     * @param {?} element
     * @param {?=} callback
     * @return {?}
     */
    function (element, callback) {
        if (callback === void 0) { callback = (/**
         * @return {?}
         */
        function () { }); }
        return __awaiter(this, void 0, void 0, function () {
            var canvas, ctx, imageData, code, EMIT_DATA;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // Get the canvas element by using the getElementById method.
                        canvas = this.canvas.nativeElement;
                        // Get a 2D drawing context for the canvas.
                        ctx = (/** @type {?} */ (canvas.getContext('2d', { willReadFrequently: true })));
                        // HTMLImageElement size
                        if (element instanceof HTMLImageElement) {
                            canvas.width = element.naturalWidth;
                            canvas.height = element.naturalHeight;
                            element.style.visibility = '';
                            this.video.nativeElement.style.visibility = 'hidden';
                            this.video.nativeElement.style.height = canvas.offsetHeight + 'px';
                        }
                        // HTMLVideoElement size
                        if (element instanceof HTMLVideoElement) {
                            canvas.width = element.videoWidth;
                            canvas.height = element.videoHeight;
                            element.style.visibility = '';
                            this.canvas.nativeElement.style.visibility = 'hidden';
                        }
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        // Draw image
                        ctx.drawImage(element, 0, 0, canvas.width, canvas.height);
                        // Data image
                        imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        // Draw frame
                        return [4 /*yield*/, zbarWasm.scanImageData(imageData)];
                    case 1:
                        code = _a.sent();
                        if (code && code.length) {
                            // Decode
                            code.forEach((/**
                             * @param {?} s
                             * @return {?}
                             */
                            function (s) { return s.value = s.decode(_this.decode && _this.decode.toLocaleLowerCase()); }));
                            // Overlay
                            DRAW_RESULT_APPEND_CHILD(code, Object.freeze(this.canvas.nativeElement), this.resultsPanel.nativeElement);
                            // To blob and emit data
                            EMIT_DATA = (/**
                             * @return {?}
                             */
                            function () {
                                _this.eventEmit(code);
                                _this.dataForResize = code;
                            });
                            // HTMLImageElement
                            if (element instanceof HTMLImageElement) {
                                callback(true);
                                EMIT_DATA();
                                VIBRATE(this.vibrate);
                                PLAY_AUDIO(this.isBeep);
                            }
                            // HTMLVideoElement
                            if (element instanceof HTMLVideoElement) {
                                EMIT_DATA();
                                VIBRATE(this.vibrate);
                                PLAY_AUDIO(this.isBeep);
                            }
                        }
                        else {
                            callback(false);
                            this.removeCanvas();
                            this.dataForResize = code;
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * removeCanvas
     */
    /**
     * removeCanvas
     * @private
     * @return {?}
     */
    NgxScannerQrcodeComponent.prototype.removeCanvas = /**
     * removeCanvas
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        Object.assign([], this.resultsPanel.nativeElement.childNodes).forEach((/**
         * @param {?} el
         * @return {?}
         */
        function (el) { return _this.resultsPanel.nativeElement.removeChild(el); }));
    };
    /**
     * status
     * @param isStart
     * @param isLoading
     */
    /**
     * status
     * @private
     * @param {?} isStart
     * @param {?} isLoading
     * @return {?}
     */
    NgxScannerQrcodeComponent.prototype.status = /**
     * status
     * @private
     * @param {?} isStart
     * @param {?} isLoading
     * @return {?}
     */
    function (isStart, isLoading) {
        this.isStart = isStart;
        this.isLoading = isLoading;
    };
    /**
     * eventEmit
     * @param response
     */
    /**
     * eventEmit
     * @private
     * @param {?=} response
     * @return {?}
     */
    NgxScannerQrcodeComponent.prototype.eventEmit = /**
     * eventEmit
     * @private
     * @param {?=} response
     * @return {?}
     */
    function (response) {
        if (response === void 0) { response = false; }
        (response !== false) && this.data.next(response || { data: null });
        (response !== false) && this.event.emit(response || { data: null });
    };
    /**
     * Single-thread
     * Loop Recording on Camera
     * Must be destroy request
     * Not using: requestAnimationFrame
     */
    /**
     * Single-thread
     * Loop Recording on Camera
     * Must be destroy request
     * Not using: requestAnimationFrame
     * @private
     * @return {?}
     */
    NgxScannerQrcodeComponent.prototype.requestAnimationFrame = /**
     * Single-thread
     * Loop Recording on Camera
     * Must be destroy request
     * Not using: requestAnimationFrame
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.rAF_ID = setInterval((/**
         * @return {?}
         */
        function () {
            if (_this.video.nativeElement.readyState === _this.video.nativeElement.HAVE_ENOUGH_DATA) {
                _this.drawImage(_this.video.nativeElement);
            }
        }), this.fps);
    };
    Object.defineProperty(NgxScannerQrcodeComponent.prototype, "isPause", {
        /**
         * Status of camera
         * @return boolean
         */
        get: /**
         * Status of camera
         * @return {?} boolean
         */
        function () {
            return this.isStart && this.video.nativeElement.paused;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NgxScannerQrcodeComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.pause();
    };
    NgxScannerQrcodeComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ngx-scanner-qrcode',
                    template: "<div #resultsPanel class=\"origin-overlay\"></div><canvas #canvas class=\"origin-canvas\"></canvas><video #video playsinline class=\"origin-video\"></video>",
                    host: { 'class': 'ngx-scanner-qrcode' },
                    exportAs: 'scanner',
                    inputs: ['src', 'fps', 'vibrate', 'decode', 'isBeep', 'deviceActive', 'config', 'constraints'],
                    outputs: ['event'],
                    queries: {
                        video: new ViewChild('video'),
                        canvas: new ViewChild('canvas'),
                        resultsPanel: new ViewChild('resultsPanel')
                    },
                    encapsulation: ViewEncapsulation.None,
                    styles: [".ngx-scanner-qrcode{display:block;position:relative}.origin-overlay{width:100%;position:absolute}.origin-overlay span{z-index:2;color:red;text-align:left;position:absolute}.origin-overlay .qrcode-polygon{z-index:1;position:absolute}.origin-canvas{width:100%;position:absolute}.origin-video{width:100%;background-color:#262626}.qrcode-tooltip{z-index:3;position:absolute}.qrcode-tooltip:hover .qrcode-tooltip-temp{display:block;position:absolute}.qrcode-tooltip-temp{bottom:0;left:50%;padding:5px;color:#fff;text-align:left;display:none;max-width:450px;border-radius:5px;width:-moz-max-content;width:max-content;word-wrap:break-word;transform:translate(-50%);transform-style:preserve-3d;background-color:#000000d0;box-shadow:1px 1px 20px #000000e0}"]
                }] }
    ];
    return NgxScannerQrcodeComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var ScannerQRCodeSymbolType = {
    ScannerQRCode_NONE: 0,
    ScannerQRCode_PARTIAL: 1,
    ScannerQRCode_EAN2: 2,
    ScannerQRCode_EAN5: 5,
    ScannerQRCode_EAN8: 8,
    ScannerQRCode_UPCE: 9,
    ScannerQRCode_ISBN10: 10,
    ScannerQRCode_UPCA: 12,
    ScannerQRCode_EAN13: 13,
    ScannerQRCode_ISBN13: 14,
    ScannerQRCode_COMPOSITE: 15,
    ScannerQRCode_I25: 25,
    ScannerQRCode_DATABAR: 34,
    ScannerQRCode_DATABAR_EXP: 35,
    ScannerQRCode_CODABAR: 38,
    ScannerQRCode_CODE39: 39,
    ScannerQRCode_PDF417: 57,
    ScannerQRCode_QRCODE: 64,
    ScannerQRCode_SQCODE: 80,
    ScannerQRCode_CODE93: 93,
    ScannerQRCode_CODE128: 128,
    /*
     * Please see _ScannerQRCode_get_symbol_hash() if adding
     * anything after 128
     */
    /** mask for base symbol type.
     * @deprecated in 0.11, remove this from existing code
     */
    ScannerQRCode_SYMBOL: 255,
    /** 2-digit add-on flag.
     * @deprecated in 0.11, a ::ScannerQRCode_EAN2 component is used for
     * 2-digit GS1 add-ons
     */
    ScannerQRCode_ADDON2: 512,
    /** 5-digit add-on flag.
     * @deprecated in 0.11, a ::ScannerQRCode_EAN5 component is used for
     * 5-digit GS1 add-ons
     */
    ScannerQRCode_ADDON5: 1280,
    /** add-on flag mask.
     * @deprecated in 0.11, GS1 add-ons are represented using composite
     * symbols of type ::ScannerQRCode_COMPOSITE; add-on components use ::ScannerQRCode_EAN2
     * or ::ScannerQRCode_EAN5
     */
    ScannerQRCode_ADDON: 1792,
};
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_NONE] = 'ScannerQRCode_NONE';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_PARTIAL] = 'ScannerQRCode_PARTIAL';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_EAN2] = 'ScannerQRCode_EAN2';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_EAN5] = 'ScannerQRCode_EAN5';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_EAN8] = 'ScannerQRCode_EAN8';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_UPCE] = 'ScannerQRCode_UPCE';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_ISBN10] = 'ScannerQRCode_ISBN10';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_UPCA] = 'ScannerQRCode_UPCA';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_EAN13] = 'ScannerQRCode_EAN13';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_ISBN13] = 'ScannerQRCode_ISBN13';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_COMPOSITE] = 'ScannerQRCode_COMPOSITE';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_I25] = 'ScannerQRCode_I25';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_DATABAR] = 'ScannerQRCode_DATABAR';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_DATABAR_EXP] = 'ScannerQRCode_DATABAR_EXP';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_CODABAR] = 'ScannerQRCode_CODABAR';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_CODE39] = 'ScannerQRCode_CODE39';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_PDF417] = 'ScannerQRCode_PDF417';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_QRCODE] = 'ScannerQRCode_QRCODE';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_SQCODE] = 'ScannerQRCode_SQCODE';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_CODE93] = 'ScannerQRCode_CODE93';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_CODE128] = 'ScannerQRCode_CODE128';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_SYMBOL] = 'ScannerQRCode_SYMBOL';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_ADDON2] = 'ScannerQRCode_ADDON2';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_ADDON5] = 'ScannerQRCode_ADDON5';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_ADDON] = 'ScannerQRCode_ADDON';
/** @enum {number} */
var ScannerQRCodeConfigType = {
    ScannerQRCode_CFG_ENABLE: 0,
    ScannerQRCode_CFG_ADD_CHECK: 1,
    ScannerQRCode_CFG_EMIT_CHECK: 2,
    ScannerQRCode_CFG_ASCII: 3,
    ScannerQRCode_CFG_BINARY: 4,
    ScannerQRCode_CFG_NUM: 5,
    ScannerQRCode_CFG_MIN_LEN: 32,
    ScannerQRCode_CFG_MAX_LEN: 33,
    ScannerQRCode_CFG_UNCERTAINTY: 64,
    ScannerQRCode_CFG_POSITION: 128,
    ScannerQRCode_CFG_TEST_INVERTED: 129,
    ScannerQRCode_CFG_X_DENSITY: 256,
    ScannerQRCode_CFG_Y_DENSITY: 257,
};
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_ENABLE] = 'ScannerQRCode_CFG_ENABLE';
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_ADD_CHECK] = 'ScannerQRCode_CFG_ADD_CHECK';
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_EMIT_CHECK] = 'ScannerQRCode_CFG_EMIT_CHECK';
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_ASCII] = 'ScannerQRCode_CFG_ASCII';
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_BINARY] = 'ScannerQRCode_CFG_BINARY';
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_NUM] = 'ScannerQRCode_CFG_NUM';
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_MIN_LEN] = 'ScannerQRCode_CFG_MIN_LEN';
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_MAX_LEN] = 'ScannerQRCode_CFG_MAX_LEN';
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_UNCERTAINTY] = 'ScannerQRCode_CFG_UNCERTAINTY';
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_POSITION] = 'ScannerQRCode_CFG_POSITION';
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_TEST_INVERTED] = 'ScannerQRCode_CFG_TEST_INVERTED';
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_X_DENSITY] = 'ScannerQRCode_CFG_X_DENSITY';
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_Y_DENSITY] = 'ScannerQRCode_CFG_Y_DENSITY';
/** @enum {number} */
var ScannerQRCodeOrientation = {
    ScannerQRCode_ORIENT_UNKNOWN: -1,
    ScannerQRCode_ORIENT_UP: 0,
    ScannerQRCode_ORIENT_RIGHT: 1,
    ScannerQRCode_ORIENT_DOWN: 2,
    ScannerQRCode_ORIENT_LEFT: 3,
};
ScannerQRCodeOrientation[ScannerQRCodeOrientation.ScannerQRCode_ORIENT_UNKNOWN] = 'ScannerQRCode_ORIENT_UNKNOWN';
ScannerQRCodeOrientation[ScannerQRCodeOrientation.ScannerQRCode_ORIENT_UP] = 'ScannerQRCode_ORIENT_UP';
ScannerQRCodeOrientation[ScannerQRCodeOrientation.ScannerQRCode_ORIENT_RIGHT] = 'ScannerQRCode_ORIENT_RIGHT';
ScannerQRCodeOrientation[ScannerQRCodeOrientation.ScannerQRCode_ORIENT_DOWN] = 'ScannerQRCode_ORIENT_DOWN';
ScannerQRCodeOrientation[ScannerQRCodeOrientation.ScannerQRCode_ORIENT_LEFT] = 'ScannerQRCode_ORIENT_LEFT';
var ScannerQRCodeTypePointer = /** @class */ (function () {
    function ScannerQRCodeTypePointer(ptr, buf) {
        this.ptr = ptr;
        this.ptr32 = ptr >> 2;
        this.buf = buf;
        this.HEAP8 = new Int8Array(buf);
        this.HEAPU32 = new Uint32Array(buf);
        this.HEAP32 = new Int32Array(buf);
    }
    return ScannerQRCodeTypePointer;
}());
var ScannerQRCodeSymbolPtr = /** @class */ (function (_super) {
    __extends(ScannerQRCodeSymbolPtr, _super);
    function ScannerQRCodeSymbolPtr() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ScannerQRCodeSymbolPtr.prototype, "type", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (this.HEAPU32[this.ptr32]));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScannerQRCodeSymbolPtr.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var len = this.HEAPU32[this.ptr32 + 4];
            /** @type {?} */
            var ptr = this.HEAPU32[this.ptr32 + 5];
            return Int8Array.from(this.HEAP8.subarray(ptr, ptr + len));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScannerQRCodeSymbolPtr.prototype, "points", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var len = this.HEAPU32[this.ptr32 + 7];
            /** @type {?} */
            var ptr = this.HEAPU32[this.ptr32 + 8];
            /** @type {?} */
            var ptr32 = ptr >> 2;
            /** @type {?} */
            var res = [];
            for (var i = 0; i < len; ++i) {
                /** @type {?} */
                var x = this.HEAP32[ptr32 + i * 2];
                /** @type {?} */
                var y = this.HEAP32[ptr32 + i * 2 + 1];
                res.push((/** @type {?} */ ({ x: x, y: y })));
            }
            return res;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScannerQRCodeSymbolPtr.prototype, "orientation", {
        get: /**
         * @return {?}
         */
        function () {
            return this.HEAP32[this.ptr32 + 9];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScannerQRCodeSymbolPtr.prototype, "next", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var ptr = this.HEAPU32[this.ptr32 + 11];
            if (!ptr)
                return null;
            return new ScannerQRCodeSymbolPtr(ptr, this.buf);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScannerQRCodeSymbolPtr.prototype, "time", {
        get: /**
         * @return {?}
         */
        function () {
            return this.HEAPU32[this.ptr32 + 13];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScannerQRCodeSymbolPtr.prototype, "cacheCount", {
        get: /**
         * @return {?}
         */
        function () {
            return this.HEAP32[this.ptr32 + 14];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScannerQRCodeSymbolPtr.prototype, "quality", {
        get: /**
         * @return {?}
         */
        function () {
            return this.HEAP32[this.ptr32 + 15];
        },
        enumerable: true,
        configurable: true
    });
    return ScannerQRCodeSymbolPtr;
}(ScannerQRCodeTypePointer));
var SymbolSetPtr = /** @class */ (function (_super) {
    __extends(SymbolSetPtr, _super);
    function SymbolSetPtr() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(SymbolSetPtr.prototype, "head", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var ptr = this.HEAPU32[this.ptr32 + 2];
            if (!ptr)
                return null;
            return new ScannerQRCodeSymbolPtr(ptr, this.buf);
        },
        enumerable: true,
        configurable: true
    });
    return SymbolSetPtr;
}(ScannerQRCodeTypePointer));
var ScannerQRCodeResult = /** @class */ (function () {
    function ScannerQRCodeResult(ptr) {
        this.value = '';
        this.type = ptr.type;
        this.typeName = ScannerQRCodeSymbolType[this.type];
        this.data = ptr.data;
        this.points = ptr.points;
        this.orientation = ptr.orientation;
        this.time = ptr.time;
        this.cacheCount = ptr.cacheCount;
        this.quality = ptr.quality;
    }
    /**
     * @param {?} ptr
     * @param {?} buf
     * @return {?}
     */
    ScannerQRCodeResult.createSymbolsFromPtr = /**
     * @param {?} ptr
     * @param {?} buf
     * @return {?}
     */
    function (ptr, buf) {
        if (ptr == 0)
            return [];
        /** @type {?} */
        var set = new SymbolSetPtr(ptr, buf);
        /** @type {?} */
        var symbol = set.head;
        /** @type {?} */
        var res = [];
        while (symbol !== null) {
            res.push(new ScannerQRCodeResult(symbol));
            symbol = symbol.next;
        }
        return res;
    };
    /**
     * @param {?=} encoding
     * @return {?}
     */
    ScannerQRCodeResult.prototype.decode = /**
     * @param {?=} encoding
     * @return {?}
     */
    function (encoding) {
        /** @type {?} */
        var decoder = new TextDecoder(encoding);
        return decoder.decode(this.data);
    };
    return ScannerQRCodeResult;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxScannerQrcodeModule = /** @class */ (function () {
    function NgxScannerQrcodeModule() {
    }
    NgxScannerQrcodeModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [NgxScannerQrcodeComponent],
                    exports: [NgxScannerQrcodeComponent],
                    providers: [NgxScannerQrcodeService],
                },] }
    ];
    return NgxScannerQrcodeModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgxScannerQrcodeService, NgxScannerQrcodeComponent, ScannerQRCodeSymbolType, ScannerQRCodeConfigType, ScannerQRCodeOrientation, ScannerQRCodeResult, NgxScannerQrcodeModule };

//# sourceMappingURL=ngx-scanner-qrcode.js.map