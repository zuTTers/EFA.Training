import { __awaiter } from 'tslib';
import { AsyncSubject, BehaviorSubject } from 'rxjs';
import { Injectable, NgModule, defineInjectable, EventEmitter, Component, ViewChild, ViewEncapsulation } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const MEDIA_STREAM_DEFAULT = {
    audio: false,
    video: true
};
/** @type {?} */
const CONFIG_DEFAULT = {
    src: '',
    fps: 30,
    vibrate: 300,
    decode: 'utf-8',
    isBeep: true,
    deviceActive: 0,
    constraints: MEDIA_STREAM_DEFAULT,
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * OVERRIDES
 * \@param variableKey
 * \@param config
 * \@param defaultConfig
 * \@return
 * @type {?}
 */
const OVERRIDES = (/**
 * @param {?} variableKey
 * @param {?} config
 * @param {?} defaultConfig
 * @return {?}
 */
(variableKey, config, defaultConfig) => {
    if (config && Object.keys(config[variableKey]).length) {
        for (const key in defaultConfig) {
            /** @type {?} */
            const cloneDeep = JSON.parse(JSON.stringify(Object.assign({}, config[variableKey], { [key]: ((/** @type {?} */ (defaultConfig)))[key] })));
            config[variableKey] = config[variableKey].hasOwnProperty(key) ? config[variableKey] : cloneDeep;
        }
        return config[variableKey];
    }
    else {
        return defaultConfig;
    }
});
/**
 * Rxjs complete
 * \@param as
 * \@param data
 * \@param error
 * @type {?}
 */
const AS_COMPLETE = (/**
 * @param {?} as
 * @param {?} data
 * @param {?=} error
 * @return {?}
 */
(as, data, error = null) => {
    error ? as.error(error) : as.next(data);
    as.complete();
});
/**
 * CAMERA_BEEP
 * \@param isPlay
 * \@return
 * @type {?}
 */
const PLAY_AUDIO = (/**
 * @param {?=} isPlay
 * @return {?}
 */
(isPlay = false) => {
    if (isPlay === false)
        return;
    /** @type {?} */
    const audio = new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU' + Array(300).join('101'));
    // when the sound has been loaded, execute your code
    audio.oncanplaythrough = (/**
     * @return {?}
     */
    () => {
        /** @type {?} */
        const promise = audio.play();
        if (promise) {
            promise.catch((/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                if (e.name === "NotAllowedError" || e.name === "NotSupportedError") ;
            }));
        }
    });
});
/**
 * HAS_OWN_PROPERTY
 * Fix issue vs ng v 6-7-8
 * Optional chaining (?.) just have on ng v 9++
 * eg: HAS_OWN_PROPERTY(config, 'frameOptions.style') // output: boolean
 * \@param obj
 * \@param propertyPath
 * \@return
 * @type {?}
 */
const HAS_OWN_PROPERTY = (/**
 * @param {?} obj
 * @param {?} propertyPath
 * @return {?}
 */
(obj, propertyPath) => {
    /** @type {?} */
    const properties = propertyPath.split(".");
    for (let i = 0; i < properties.length; i++) {
        /** @type {?} */
        let prop = properties[i];
        if (!obj.hasOwnProperty(prop)) {
            return false;
        }
        else {
            obj = obj[prop];
        }
    }
    return true;
});
/**
 * DRAW_RESULT_APPEND_CHILD
 * \@param code
 * \@param oriCanvas
 * \@param elTarget
 * @type {?}
 */
const DRAW_RESULT_APPEND_CHILD = (/**
 * @param {?} code
 * @param {?} oriCanvas
 * @param {?} elTarget
 * @return {?}
 */
(code, oriCanvas, elTarget) => {
    /** @type {?} */
    let widthZoom;
    /** @type {?} */
    let heightZoom;
    /** @type {?} */
    let oriWidth = oriCanvas.width;
    /** @type {?} */
    let oriHeight = oriCanvas.height;
    /** @type {?} */
    let oriWHRatio = oriWidth / oriHeight;
    /** @type {?} */
    let imgWidth = parseInt(getComputedStyle(oriCanvas).width);
    /** @type {?} */
    let imgHeight = parseInt(getComputedStyle(oriCanvas).height);
    /** @type {?} */
    let imgWHRatio = imgWidth / imgHeight;
    elTarget.innerHTML = '';
    if (oriWHRatio > imgWHRatio) {
        widthZoom = imgWidth / oriWidth;
        heightZoom = imgWidth / oriWHRatio / oriHeight;
    }
    else {
        heightZoom = imgHeight / oriHeight;
        widthZoom = (imgHeight * oriWHRatio) / oriWidth;
    }
    for (let i = 0; i < code.length; i++) {
        /** @type {?} */
        const _code = code[i];
        // New canvas
        /** @type {?} */
        let cvs = document.createElement("canvas");
        /** @type {?} */
        let ctx = (/** @type {?} */ (cvs.getContext('2d', { willReadFrequently: true })));
        /** @type {?} */
        let loc = {};
        /** @type {?} */
        let X = [];
        /** @type {?} */
        let Y = [];
        // Point x,y
        /** @type {?} */
        const points = _code.points;
        for (let j = 0; j < points.length; j++) {
            /** @type {?} */
            const xj = HAS_OWN_PROPERTY(points, `${j}.x`) ? points[j].x : 0;
            /** @type {?} */
            const yj = HAS_OWN_PROPERTY(points, `${j}.y`) ? points[j].y : 0;
            loc[`x${j + 1}`] = xj;
            loc[`y${j + 1}`] = yj;
            X.push(xj);
            Y.push(yj);
        }
        // Min max
        /** @type {?} */
        let maxX = Math.max(...X);
        /** @type {?} */
        let minX = Math.min(...X);
        /** @type {?} */
        let maxY = Math.max(...Y);
        /** @type {?} */
        let minY = Math.min(...Y);
        // Add class
        cvs.setAttribute('class', 'qrcode-polygon');
        // Size with screen zoom
        if (oriWHRatio > imgWHRatio) {
            cvs.style.top = minY * heightZoom + (imgHeight - imgWidth / oriWHRatio) * 0.5 + "px";
            cvs.style.left = minX * widthZoom + "px";
            cvs.width = (maxX - minX) * widthZoom;
            cvs.height = (maxY - minY) * widthZoom;
        }
        else {
            cvs.style.top = minY * heightZoom + "px";
            cvs.style.left = minX * widthZoom + (imgWidth - imgHeight * oriWHRatio) * 0.5 + "px";
            cvs.width = (maxX - minX) * heightZoom;
            cvs.height = (maxY - minY) * heightZoom;
        }
        // Style for canvas
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'green';
        ctx.fillStyle = "#55f02880";
        // polygon [x,y, x,y, x,y.....];
        /** @type {?} */
        const polygon = [];
        for (let k = 0; k < X.length; k++) {
            polygon.push((loc[`x${k + 1}`] - minX) * heightZoom);
            polygon.push((loc[`y${k + 1}`] - minY) * widthZoom);
        }
        // Copy array
        /** @type {?} */
        const shape = (/** @type {?} */ (polygon.slice(0)));
        // Draw polygon
        ctx.beginPath();
        ctx.moveTo(shape.shift(), shape.shift());
        while (shape.length) {
            ctx.lineTo(shape.shift(), shape.shift()); //x,y
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        // Tooltip result
        /** @type {?} */
        const qrcodeTooltipTemp = document.createElement('div');
        qrcodeTooltipTemp.setAttribute('class', 'qrcode-tooltip-temp');
        qrcodeTooltipTemp.innerText = _code.value;
        // Tooltip box
        /** @type {?} */
        const qrcodeTooltip = document.createElement('div');
        qrcodeTooltip.setAttribute('class', 'qrcode-tooltip');
        qrcodeTooltip.appendChild(qrcodeTooltipTemp);
        heightZoom = imgHeight / oriHeight;
        widthZoom = (imgHeight * oriWHRatio) / oriWidth;
        qrcodeTooltip.style.fontSize = widthZoom * 15 + 'px';
        qrcodeTooltip.style.top = minY * heightZoom + "px";
        qrcodeTooltip.style.left = minX * widthZoom + (imgWidth - imgHeight * oriWHRatio) * 0.5 + "px";
        qrcodeTooltip.style.width = (maxX - minX) * heightZoom + "px";
        qrcodeTooltip.style.height = (maxY - minY) * heightZoom + "px";
        // Result text
        /** @type {?} */
        const resultText = document.createElement('span');
        resultText.innerText = _code.value;
        resultText.style.fontSize = widthZoom * 13 + 'px';
        // Set position result text
        resultText.style.top = minY * heightZoom + (-20 * heightZoom) + "px";
        resultText.style.left = minX * widthZoom + (imgWidth - imgHeight * oriWHRatio) * 0.5 + "px";
        if (elTarget) {
            elTarget.appendChild(qrcodeTooltip);
            elTarget.appendChild(resultText);
            elTarget.appendChild(cvs);
        }
    }
})
/**
 * DRAW_RESULT_ON_CANVAS
 * @param code
 * @param cvs
 */
;
/**
 * DRAW_RESULT_ON_CANVAS
 * \@param code
 * \@param cvs
 * @type {?}
 */
const DRAW_RESULT_ON_CANVAS = (/**
 * @param {?} code
 * @param {?} cvs
 * @return {?}
 */
(code, cvs) => {
    /** @type {?} */
    let ctx = (/** @type {?} */ (cvs.getContext('2d', { willReadFrequently: true })));
    for (let i = 0; i < code.length; i++) {
        /** @type {?} */
        const _code = code[i];
        /** @type {?} */
        let loc = {};
        /** @type {?} */
        let X = [];
        /** @type {?} */
        let Y = [];
        // Point x,y
        /** @type {?} */
        const points = _code.points;
        for (let j = 0; j < points.length; j++) {
            /** @type {?} */
            const xj = HAS_OWN_PROPERTY(points, `${j}.x`) ? points[j].x : 0;
            /** @type {?} */
            const yj = HAS_OWN_PROPERTY(points, `${j}.y`) ? points[j].y : 0;
            loc[`x${j + 1}`] = xj;
            loc[`y${j + 1}`] = yj;
            X.push(xj);
            Y.push(yj);
        }
        // Min max
        /** @type {?} */
        let minX = Math.min(...X);
        /** @type {?} */
        let minY = Math.min(...Y);
        // Style for canvas
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'green';
        ctx.fillStyle = "#55f02880";
        ctx.font = "15px serif";
        FILL_TEXT_MULTI_LINE(ctx, _code.value, minX, minY - 5);
        // polygon [x,y, x,y, x,y.....];
        /** @type {?} */
        const polygon = [];
        for (let k = 0; k < X.length; k++) {
            polygon.push(loc[`x${k + 1}`]);
            polygon.push(loc[`y${k + 1}`]);
        }
        // Copy array
        /** @type {?} */
        const shape = (/** @type {?} */ (polygon.slice(0)));
        // Draw polygon
        ctx.beginPath();
        ctx.moveTo(shape.shift(), shape.shift());
        while (shape.length) {
            ctx.lineTo(shape.shift(), shape.shift()); //x,y
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }
})
/**
 * READ_AS_DATA_URL
 * @param file
 * @param config
 * @return Promise
 */
;
/**
 * READ_AS_DATA_URL
 * \@param file
 * \@param config
 * \@return Promise
 * @type {?}
 */
const READ_AS_DATA_URL = (/**
 * @param {?} file
 * @param {?} config
 * @return {?}
 */
(file, config) => {
    /**
     * overrides *
     * @type {?}
     */
    let decode = HAS_OWN_PROPERTY(config, 'decode') ? config.decode : CONFIG_DEFAULT.decode;
    /** drawImage **/
    return new Promise((/**
     * @param {?} resolve
     * @param {?} reject
     * @return {?}
     */
    (resolve, reject) => {
        /** @type {?} */
        const fileReader = new FileReader();
        fileReader.onload = (/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const objectFile = {
                name: file.name,
                file: file,
                url: URL.createObjectURL(file)
            };
            // Set the src of this Image object.
            /** @type {?} */
            const image = new Image();
            // Setting cross origin value to anonymous
            image.setAttribute('crossOrigin', 'anonymous');
            // When our image has loaded.
            image.onload = (/**
             * @return {?}
             */
            () => __awaiter(this, void 0, void 0, function* () {
                // Get the canvas element by using the getElementById method.
                /** @type {?} */
                const canvas = document.createElement('canvas');
                // HTMLImageElement size
                canvas.width = image.naturalWidth || image.width;
                canvas.height = image.naturalHeight || image.height;
                // Get a 2D drawing context for the canvas.
                /** @type {?} */
                const ctx = (/** @type {?} */ (canvas.getContext('2d')));
                // Draw image
                ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
                // Data image
                /** @type {?} */
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                // Scanner
                /** @type {?} */
                const code = yield zbarWasm.scanImageData(imageData);
                if (code && code.length) {
                    // Decode
                    code.forEach((/**
                     * @param {?} s
                     * @return {?}
                     */
                    (s) => s.value = s.decode(decode && decode.toLocaleLowerCase())));
                    // Overlay
                    DRAW_RESULT_ON_CANVAS(code, canvas);
                    // Emit object
                    /** @type {?} */
                    const blob = yield CANVAS_TO_BLOB(canvas);
                    /** @type {?} */
                    const url = URL.createObjectURL(blob);
                    /** @type {?} */
                    const blobToFile = (/**
                     * @param {?} theBlob
                     * @param {?} fileName
                     * @return {?}
                     */
                    (theBlob, fileName) => new File([theBlob], fileName, { lastModified: new Date().getTime(), type: theBlob.type }));
                    resolve(Object.assign({}, objectFile, { data: code, url: url, canvas: canvas, file: blobToFile(blob, objectFile.name) }));
                }
                else {
                    resolve(Object.assign({}, objectFile, { data: code, canvas: canvas }));
                }
            }));
            // Set src
            image.src = objectFile.url;
        });
        fileReader.onerror = (/**
         * @param {?} error
         * @return {?}
         */
        (error) => reject(error));
        fileReader.readAsDataURL(file);
    }));
})
/**
 * Convert canvas to blob
 * canvas.toBlob((blob) => { .. }, 'image/jpeg', 0.95); // JPEG at 95% quality
 * @param canvas
 * @param type
 * @return Promise
 */
;
/**
 * Convert canvas to blob
 * canvas.toBlob((blob) => { .. }, 'image/jpeg', 0.95); // JPEG at 95% quality
 * \@param canvas
 * \@param type
 * \@return Promise
 * @type {?}
 */
const CANVAS_TO_BLOB = (/**
 * @param {?} canvas
 * @param {?=} type
 * @return {?}
 */
(canvas, type) => {
    return new Promise((/**
     * @param {?} resolve
     * @param {?} reject
     * @return {?}
     */
    (resolve, reject) => canvas.toBlob((/**
     * @param {?} blob
     * @return {?}
     */
    blob => resolve(blob)), type)));
})
/**
 * Convert blob to file
 * @param theBlob
 * @param fileName
 * @return File
 */
;
/**
 * Convert blob to file
 * \@param theBlob
 * \@param fileName
 * \@return File
 * @type {?}
 */
const BLOB_TO_FILE = (/**
 * @param {?} theBlob
 * @param {?} fileName
 * @return {?}
 */
(theBlob, fileName) => {
    return new File([theBlob], fileName, { lastModified: new Date().getTime(), type: theBlob.type });
})
/**
 * FILES_TO_SCAN
 * @param files
 * @return AsyncSubject
 */
;
/**
 * FILES_TO_SCAN
 * \@param files
 * \@return AsyncSubject
 * @type {?}
 */
const FILES_TO_SCAN = (/**
 * @param {?=} files
 * @param {?=} configs
 * @param {?=} as
 * @return {?}
 */
(files = [], configs, as = new AsyncSubject()) => {
    Promise.all(Object.assign([], files).map((/**
     * @param {?} m
     * @return {?}
     */
    m => READ_AS_DATA_URL(m, configs)))).then((/**
     * @param {?} img
     * @return {?}
     */
    (img) => AS_COMPLETE(as, img))).catch((/**
     * @param {?} error
     * @return {?}
     */
    (error) => AS_COMPLETE(as, null, error)));
    return as;
})
/**
 * FILL_TEXT_MULTI_LINE
 * @param ctx
 * @param text
 * @param x
 * @param y
 */
;
/**
 * FILL_TEXT_MULTI_LINE
 * \@param ctx
 * \@param text
 * \@param x
 * \@param y
 * @type {?}
 */
const FILL_TEXT_MULTI_LINE = (/**
 * @param {?} ctx
 * @param {?} text
 * @param {?} x
 * @param {?} y
 * @return {?}
 */
(ctx, text, x, y) => {
    /** @type {?} */
    let lineHeight = ctx.measureText("M").width * 1.2;
    /** @type {?} */
    let lines = text.split("\n");
    for (var i = 0; i < lines.length; ++i) {
        ctx.fillText(lines[i], x, y);
        ctx.strokeText(lines[i], x, y);
        y += lineHeight;
    }
})
/**
 * VIBRATE
 * Bật rung trên mobile
 * @param time
 */
;
/**
 * VIBRATE
 * Bật rung trên mobile
 * \@param time
 * @type {?}
 */
const VIBRATE = (/**
 * @param {?} time
 * @return {?}
 */
(time) => {
    time && IS_MOBILE() && window.navigator.vibrate(time);
});
/**
 * IS_MOBILE
 * \@return
 * @type {?}
 */
const IS_MOBILE = (/**
 * @return {?}
 */
() => {
    /** @type {?} */
    const vendor = navigator.userAgent || navigator['vendor'] || window['opera'];
    return !!(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(vendor) ||
        /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(vendor.substr(0, 4)));
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxScannerQrcodeService {
    /**
     * Load files
     * @param {?=} files
     * @return {?} AsyncSubject
     */
    loadFiles(files = []) {
        /** @type {?} */
        const as = new AsyncSubject();
        Promise.all(Object.assign([], files).map((/**
         * @param {?} m
         * @return {?}
         */
        m => this.readAsDataURL(m)))).then((/**
         * @param {?} img
         * @return {?}
         */
        (img) => AS_COMPLETE(as, img))).catch((/**
         * @param {?} error
         * @return {?}
         */
        (error) => AS_COMPLETE(as, null, error)));
        return as;
    }
    /**
     * loadFilesToScan
     * @param {?=} files
     * @param {?=} config
     * @return {?}
     */
    loadFilesToScan(files = [], config) {
        return FILES_TO_SCAN(files, config);
    }
    /**
     * readAsDataURL
     * @private
     * @param {?} file
     * @return {?} Promise
     */
    readAsDataURL(file) {
        /** drawImage **/
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            /** @type {?} */
            const fileReader = new FileReader();
            fileReader.onload = (/**
             * @return {?}
             */
            () => {
                /** @type {?} */
                const objectFile = {
                    name: file.name,
                    file: file,
                    url: URL.createObjectURL(file)
                };
                resolve(objectFile);
            });
            fileReader.onerror = (/**
             * @param {?} error
             * @return {?}
             */
            (error) => reject(error));
            fileReader.readAsDataURL(file);
        }));
    }
}
NgxScannerQrcodeService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ NgxScannerQrcodeService.ngInjectableDef = defineInjectable({ factory: function NgxScannerQrcodeService_Factory() { return new NgxScannerQrcodeService(); }, token: NgxScannerQrcodeService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxScannerQrcodeComponent {
    constructor() {
        /**
         * EventEmitter
         */
        this.event = new EventEmitter();
        /**
         * Input
         */
        this.src = CONFIG_DEFAULT.src;
        this.fps = CONFIG_DEFAULT.fps;
        this.vibrate = CONFIG_DEFAULT.vibrate;
        this.decode = CONFIG_DEFAULT.decode;
        this.isBeep = CONFIG_DEFAULT.isBeep;
        this.deviceActive = CONFIG_DEFAULT.deviceActive;
        this.config = CONFIG_DEFAULT;
        this.constraints = CONFIG_DEFAULT.constraints;
        /**
         * Export
         */
        this.isStart = false;
        this.isLoading = false;
        this.isTorch = false;
        this.data = new BehaviorSubject([]);
        this.devices = new BehaviorSubject([]);
        this.dataForResize = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.overrideConfig();
        if (this.src) {
            this.loadImage(this.src);
        }
        this.resize();
    }
    /**
     * start
     * @return {?} AsyncSubject
     */
    start() {
        /** @type {?} */
        const as = new AsyncSubject();
        if (this.isStart) {
            // Reject
            AS_COMPLETE(as, false);
        }
        else {
            // mediaDevices
            this.loadAllDevices(as);
        }
        return as;
    }
    /**
     * playDevice
     * @param {?} deviceId
     * @param {?=} as
     * @return {?} AsyncSubject
     */
    playDevice(deviceId, as = new AsyncSubject()) {
        /** @type {?} */
        const existDeviceId = this.isStart ? this.getConstraints().deviceId != deviceId : true;
        switch (true) {
            case deviceId == 'null' || deviceId == null:
                this.stop();
                AS_COMPLETE(as, false);
                break;
            case deviceId && existDeviceId:
                stop();
                this.stop();
                clearInterval(this.rAF_ID);
                // Loading on
                this.status(false, true);
                /** @type {?} */
                const constraints = {
                    audio: false,
                    video: (typeof (this.constraints && this.constraints.video) === 'boolean') ? { deviceId: deviceId } : Object.assign({ deviceId: deviceId }, this.constraints && this.constraints.video)
                };
                this.deviceActive = this.devices.value.findIndex((/**
                 * @param {?} f
                 * @return {?}
                 */
                f => f.deviceId == deviceId));
                // MediaStream
                navigator.mediaDevices.getUserMedia(constraints).then((/**
                 * @param {?} stream
                 * @return {?}
                 */
                (stream) => {
                    this.video.nativeElement.srcObject = stream;
                    this.video.nativeElement.onloadedmetadata = (/**
                     * @return {?}
                     */
                    () => {
                        this.video.nativeElement.play();
                        this.requestAnimationFrame();
                        this.status(true, false);
                        AS_COMPLETE(as, true);
                    });
                })).catch((/**
                 * @param {?} error
                 * @return {?}
                 */
                error => {
                    this.status(false, false);
                    this.eventEmit(false);
                    AS_COMPLETE(as, false, error);
                }));
                break;
            default:
                AS_COMPLETE(as, false);
                break;
        }
        return as;
    }
    /**
     * stop
     * @return {?} AsyncSubject
     */
    stop() {
        this.eventEmit(null);
        this.status(false, false);
        /** @type {?} */
        const as = new AsyncSubject();
        try {
            this.removeCanvas();
            clearInterval(this.rAF_ID);
            ((/** @type {?} */ (this.video.nativeElement.srcObject))).getTracks().forEach((/**
             * @param {?} track
             * @return {?}
             */
            (track) => {
                track.stop();
                AS_COMPLETE(as, true);
            }));
        }
        catch (error) {
            AS_COMPLETE(as, false, (/** @type {?} */ (error)));
        }
        return as;
    }
    /**
     * play
     * @return {?} AsyncSubject
     */
    play() {
        /** @type {?} */
        const as = new AsyncSubject();
        if (this.isPause) {
            this.video.nativeElement.play();
            this.requestAnimationFrame();
            AS_COMPLETE(as, true);
        }
        else {
            AS_COMPLETE(as, false);
        }
        return as;
    }
    /**
     * pause
     * @return {?} AsyncSubject
     */
    pause() {
        /** @type {?} */
        const as = new AsyncSubject();
        if (this.isStart) {
            clearInterval(this.rAF_ID);
            this.video.nativeElement.pause();
            AS_COMPLETE(as, true);
        }
        else {
            AS_COMPLETE(as, false);
        }
        return as;
    }
    /**
     * loadImage
     * @param {?} src
     * @return {?} AsyncSubject
     */
    loadImage(src) {
        /** @type {?} */
        const as = new AsyncSubject();
        // Loading on
        this.status(false, true);
        // Set the src of this Image object.
        /** @type {?} */
        const image = new Image();
        // Setting cross origin value to anonymous
        image.setAttribute('crossOrigin', 'anonymous');
        // When our image has loaded.
        image.onload = (/**
         * @return {?}
         */
        () => {
            this.drawImage(image, (/**
             * @param {?} flag
             * @return {?}
             */
            (flag) => {
                this.status(false, false);
                AS_COMPLETE(as, flag);
            }));
        });
        // Set src
        image.src = src;
        return as;
    }
    /**
     * torcher
     * @return {?} AsyncSubject
     */
    torcher() {
        /** @type {?} */
        const as = this.applyConstraints({ torch: this.isTorch });
        as.subscribe((/**
         * @return {?}
         */
        () => false), (/**
         * @return {?}
         */
        () => this.isTorch = !this.isTorch));
        return as;
    }
    /**
     * applyConstraints
     * @param {?} constraints
     * @return {?} AsyncSubject
     */
    applyConstraints(constraints) {
        /** @type {?} */
        const as = new AsyncSubject();
        /** @type {?} */
        const stream = (/** @type {?} */ (this.video.nativeElement.srcObject));
        /** @type {?} */
        const videoTrack = (/** @type {?} */ (stream.getVideoTracks()[0]));
        /** @type {?} */
        const imageCapture = new ((/** @type {?} */ (window))).ImageCapture(videoTrack);
        imageCapture.getPhotoCapabilities().then((/**
         * @return {?}
         */
        () => __awaiter(this, void 0, void 0, function* () {
            yield videoTrack.applyConstraints((/** @type {?} */ ({ advanced: [constraints] })));
            AS_COMPLETE(as, true);
        }))).catch((/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            switch (error && error.name) {
                case 'NotFoundError':
                case 'DevicesNotFoundError':
                    AS_COMPLETE(as, false, (/** @type {?} */ ('Required track is missing')));
                    break;
                case 'NotReadableError':
                case 'TrackStartError':
                    AS_COMPLETE(as, false, (/** @type {?} */ ('Webcam or mic are already in use')));
                    break;
                case 'OverconstrainedError':
                case 'ConstraintNotSatisfiedError':
                    AS_COMPLETE(as, false, (/** @type {?} */ ('Constraints can not be satisfied by avb. devices')));
                    break;
                case 'NotAllowedError':
                case 'PermissionDeniedError':
                    AS_COMPLETE(as, false, (/** @type {?} */ ('Permission denied in browser')));
                    break;
                case 'TypeError':
                    AS_COMPLETE(as, false, (/** @type {?} */ ('Empty constraints object')));
                    break;
                default:
                    AS_COMPLETE(as, false, (/** @type {?} */ (error)));
                    break;
            }
        }));
        return as;
    }
    ;
    /**
     * getConstraints
     * @return {?}
     */
    getConstraints() {
        /** @type {?} */
        const stream = (/** @type {?} */ (this.video.nativeElement.srcObject));
        /** @type {?} */
        const videoTrack = stream && (/** @type {?} */ (stream.getVideoTracks()[0]));
        return videoTrack && (/** @type {?} */ (videoTrack.getConstraints()));
    }
    /**
     * download
     * @param {?=} fileName
     * @return {?} AsyncSubject
     */
    download(fileName = `ngx-scanner-qrcode-${Date.now()}.png`) {
        /** @type {?} */
        const as = new AsyncSubject();
        /** @type {?} */
        const run = (/**
         * @return {?}
         */
        () => __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const blob = yield CANVAS_TO_BLOB(this.canvas.nativeElement);
            /** @type {?} */
            const file = BLOB_TO_FILE(blob, fileName);
            FILES_TO_SCAN([file], this.config, as).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            (res) => {
                res.forEach((/**
                 * @param {?} item
                 * @return {?}
                 */
                (item) => {
                    /** @type {?} */
                    const link = document.createElement('a');
                    link.href = item.url;
                    link.download = item.name;
                    link.click();
                    link.remove();
                }));
            }));
        }));
        run();
        return as;
    }
    /**
     * window: resize
     * Draw again!
     * @private
     * @return {?}
     */
    resize() {
        window.addEventListener("resize", (/**
         * @return {?}
         */
        () => {
            if (this.dataForResize && this.dataForResize.length) {
                DRAW_RESULT_APPEND_CHILD((/** @type {?} */ (this.dataForResize)), this.canvas.nativeElement, this.resultsPanel.nativeElement);
            }
        }));
    }
    /**
     * Override config
     * @private
     * @return {?} void
     */
    overrideConfig() {
        if (HAS_OWN_PROPERTY(this.config, 'src'))
            this.src = this.config.src;
        if (HAS_OWN_PROPERTY(this.config, 'fps'))
            this.fps = this.config.fps;
        if (HAS_OWN_PROPERTY(this.config, 'vibrate'))
            this.vibrate = this.config.vibrate;
        if (HAS_OWN_PROPERTY(this.config, 'decode'))
            this.decode = this.config.decode;
        if (HAS_OWN_PROPERTY(this.config, 'isBeep'))
            this.isBeep = this.config.isBeep;
        if (HAS_OWN_PROPERTY(this.config, 'deviceActive'))
            this.deviceActive = this.config.deviceActive;
        if (HAS_OWN_PROPERTY(this.config, 'constraints'))
            this.constraints = OVERRIDES('constraints', this.config, MEDIA_STREAM_DEFAULT);
    }
    /**
     * loadAllDevices
     * @private
     * @param {?} as
     * @return {?}
     */
    loadAllDevices(as) {
        navigator.mediaDevices.enumerateDevices().then((/**
         * @param {?} devices
         * @return {?}
         */
        devices => {
            /** @type {?} */
            let cameraDevices = [];
            devices.forEach((/**
             * @param {?} f
             * @return {?}
             */
            f => f.kind == 'videoinput' && cameraDevices.push(f)));
            this.devices.next(cameraDevices);
            if (cameraDevices.length > 0) {
                /** @type {?} */
                const index = Math.max(0, (cameraDevices.length > this.deviceActive ? this.deviceActive : 0));
                this.playDevice(cameraDevices[index].deviceId, as);
            }
            else {
                AS_COMPLETE(as, false, (/** @type {?} */ ('No camera detected.')));
            }
        }));
    }
    /**
     * drawImage
     * @private
     * @param {?} element
     * @param {?=} callback
     * @return {?}
     */
    drawImage(element, callback = (/**
     * @return {?}
     */
    () => { })) {
        return __awaiter(this, void 0, void 0, function* () {
            // Get the canvas element by using the getElementById method.
            /** @type {?} */
            const canvas = this.canvas.nativeElement;
            // Get a 2D drawing context for the canvas.
            /** @type {?} */
            const ctx = (/** @type {?} */ (canvas.getContext('2d', { willReadFrequently: true })));
            // HTMLImageElement size
            if (element instanceof HTMLImageElement) {
                canvas.width = element.naturalWidth;
                canvas.height = element.naturalHeight;
                element.style.visibility = '';
                this.video.nativeElement.style.visibility = 'hidden';
                this.video.nativeElement.style.height = canvas.offsetHeight + 'px';
            }
            // HTMLVideoElement size
            if (element instanceof HTMLVideoElement) {
                canvas.width = element.videoWidth;
                canvas.height = element.videoHeight;
                element.style.visibility = '';
                this.canvas.nativeElement.style.visibility = 'hidden';
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Draw image
            ctx.drawImage(element, 0, 0, canvas.width, canvas.height);
            // Data image
            /** @type {?} */
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            // Draw frame
            /** @type {?} */
            const code = yield zbarWasm.scanImageData(imageData);
            if (code && code.length) {
                // Decode
                code.forEach((/**
                 * @param {?} s
                 * @return {?}
                 */
                (s) => s.value = s.decode(this.decode && this.decode.toLocaleLowerCase())));
                // Overlay
                DRAW_RESULT_APPEND_CHILD(code, Object.freeze(this.canvas.nativeElement), this.resultsPanel.nativeElement);
                // To blob and emit data
                /** @type {?} */
                const EMIT_DATA = (/**
                 * @return {?}
                 */
                () => {
                    this.eventEmit(code);
                    this.dataForResize = code;
                });
                // HTMLImageElement
                if (element instanceof HTMLImageElement) {
                    callback(true);
                    EMIT_DATA();
                    VIBRATE(this.vibrate);
                    PLAY_AUDIO(this.isBeep);
                }
                // HTMLVideoElement
                if (element instanceof HTMLVideoElement) {
                    EMIT_DATA();
                    VIBRATE(this.vibrate);
                    PLAY_AUDIO(this.isBeep);
                }
            }
            else {
                callback(false);
                this.removeCanvas();
                this.dataForResize = code;
            }
        });
    }
    /**
     * removeCanvas
     * @private
     * @return {?}
     */
    removeCanvas() {
        Object.assign([], this.resultsPanel.nativeElement.childNodes).forEach((/**
         * @param {?} el
         * @return {?}
         */
        el => this.resultsPanel.nativeElement.removeChild(el)));
    }
    /**
     * status
     * @private
     * @param {?} isStart
     * @param {?} isLoading
     * @return {?}
     */
    status(isStart, isLoading) {
        this.isStart = isStart;
        this.isLoading = isLoading;
    }
    /**
     * eventEmit
     * @private
     * @param {?=} response
     * @return {?}
     */
    eventEmit(response = false) {
        (response !== false) && this.data.next(response || { data: null });
        (response !== false) && this.event.emit(response || { data: null });
    }
    /**
     * Single-thread
     * Loop Recording on Camera
     * Must be destroy request
     * Not using: requestAnimationFrame
     * @private
     * @return {?}
     */
    requestAnimationFrame() {
        this.rAF_ID = setInterval((/**
         * @return {?}
         */
        () => {
            if (this.video.nativeElement.readyState === this.video.nativeElement.HAVE_ENOUGH_DATA) {
                this.drawImage(this.video.nativeElement);
            }
        }), this.fps);
    }
    /**
     * Status of camera
     * @return {?} boolean
     */
    get isPause() {
        return this.isStart && this.video.nativeElement.paused;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.pause();
    }
}
NgxScannerQrcodeComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-scanner-qrcode',
                template: `<div #resultsPanel class="origin-overlay"></div><canvas #canvas class="origin-canvas"></canvas><video #video playsinline class="origin-video"></video>`,
                host: { 'class': 'ngx-scanner-qrcode' },
                exportAs: 'scanner',
                inputs: ['src', 'fps', 'vibrate', 'decode', 'isBeep', 'deviceActive', 'config', 'constraints'],
                outputs: ['event'],
                queries: {
                    video: new ViewChild('video'),
                    canvas: new ViewChild('canvas'),
                    resultsPanel: new ViewChild('resultsPanel')
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".ngx-scanner-qrcode{display:block;position:relative}.origin-overlay{width:100%;position:absolute}.origin-overlay span{z-index:2;color:red;text-align:left;position:absolute}.origin-overlay .qrcode-polygon{z-index:1;position:absolute}.origin-canvas{width:100%;position:absolute}.origin-video{width:100%;background-color:#262626}.qrcode-tooltip{z-index:3;position:absolute}.qrcode-tooltip:hover .qrcode-tooltip-temp{display:block;position:absolute}.qrcode-tooltip-temp{bottom:0;left:50%;padding:5px;color:#fff;text-align:left;display:none;max-width:450px;border-radius:5px;width:-moz-max-content;width:max-content;word-wrap:break-word;transform:translate(-50%);transform-style:preserve-3d;background-color:#000000d0;box-shadow:1px 1px 20px #000000e0}"]
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const ScannerQRCodeSymbolType = {
    ScannerQRCode_NONE: 0,
    ScannerQRCode_PARTIAL: 1,
    ScannerQRCode_EAN2: 2,
    ScannerQRCode_EAN5: 5,
    ScannerQRCode_EAN8: 8,
    ScannerQRCode_UPCE: 9,
    ScannerQRCode_ISBN10: 10,
    ScannerQRCode_UPCA: 12,
    ScannerQRCode_EAN13: 13,
    ScannerQRCode_ISBN13: 14,
    ScannerQRCode_COMPOSITE: 15,
    ScannerQRCode_I25: 25,
    ScannerQRCode_DATABAR: 34,
    ScannerQRCode_DATABAR_EXP: 35,
    ScannerQRCode_CODABAR: 38,
    ScannerQRCode_CODE39: 39,
    ScannerQRCode_PDF417: 57,
    ScannerQRCode_QRCODE: 64,
    ScannerQRCode_SQCODE: 80,
    ScannerQRCode_CODE93: 93,
    ScannerQRCode_CODE128: 128,
    /*
     * Please see _ScannerQRCode_get_symbol_hash() if adding
     * anything after 128
     */
    /** mask for base symbol type.
     * @deprecated in 0.11, remove this from existing code
     */
    ScannerQRCode_SYMBOL: 255,
    /** 2-digit add-on flag.
     * @deprecated in 0.11, a ::ScannerQRCode_EAN2 component is used for
     * 2-digit GS1 add-ons
     */
    ScannerQRCode_ADDON2: 512,
    /** 5-digit add-on flag.
     * @deprecated in 0.11, a ::ScannerQRCode_EAN5 component is used for
     * 5-digit GS1 add-ons
     */
    ScannerQRCode_ADDON5: 1280,
    /** add-on flag mask.
     * @deprecated in 0.11, GS1 add-ons are represented using composite
     * symbols of type ::ScannerQRCode_COMPOSITE; add-on components use ::ScannerQRCode_EAN2
     * or ::ScannerQRCode_EAN5
     */
    ScannerQRCode_ADDON: 1792,
};
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_NONE] = 'ScannerQRCode_NONE';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_PARTIAL] = 'ScannerQRCode_PARTIAL';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_EAN2] = 'ScannerQRCode_EAN2';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_EAN5] = 'ScannerQRCode_EAN5';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_EAN8] = 'ScannerQRCode_EAN8';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_UPCE] = 'ScannerQRCode_UPCE';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_ISBN10] = 'ScannerQRCode_ISBN10';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_UPCA] = 'ScannerQRCode_UPCA';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_EAN13] = 'ScannerQRCode_EAN13';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_ISBN13] = 'ScannerQRCode_ISBN13';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_COMPOSITE] = 'ScannerQRCode_COMPOSITE';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_I25] = 'ScannerQRCode_I25';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_DATABAR] = 'ScannerQRCode_DATABAR';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_DATABAR_EXP] = 'ScannerQRCode_DATABAR_EXP';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_CODABAR] = 'ScannerQRCode_CODABAR';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_CODE39] = 'ScannerQRCode_CODE39';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_PDF417] = 'ScannerQRCode_PDF417';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_QRCODE] = 'ScannerQRCode_QRCODE';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_SQCODE] = 'ScannerQRCode_SQCODE';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_CODE93] = 'ScannerQRCode_CODE93';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_CODE128] = 'ScannerQRCode_CODE128';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_SYMBOL] = 'ScannerQRCode_SYMBOL';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_ADDON2] = 'ScannerQRCode_ADDON2';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_ADDON5] = 'ScannerQRCode_ADDON5';
ScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_ADDON] = 'ScannerQRCode_ADDON';
/** @enum {number} */
const ScannerQRCodeConfigType = {
    ScannerQRCode_CFG_ENABLE: 0,
    ScannerQRCode_CFG_ADD_CHECK: 1,
    ScannerQRCode_CFG_EMIT_CHECK: 2,
    ScannerQRCode_CFG_ASCII: 3,
    ScannerQRCode_CFG_BINARY: 4,
    ScannerQRCode_CFG_NUM: 5,
    ScannerQRCode_CFG_MIN_LEN: 32,
    ScannerQRCode_CFG_MAX_LEN: 33,
    ScannerQRCode_CFG_UNCERTAINTY: 64,
    ScannerQRCode_CFG_POSITION: 128,
    ScannerQRCode_CFG_TEST_INVERTED: 129,
    ScannerQRCode_CFG_X_DENSITY: 256,
    ScannerQRCode_CFG_Y_DENSITY: 257,
};
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_ENABLE] = 'ScannerQRCode_CFG_ENABLE';
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_ADD_CHECK] = 'ScannerQRCode_CFG_ADD_CHECK';
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_EMIT_CHECK] = 'ScannerQRCode_CFG_EMIT_CHECK';
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_ASCII] = 'ScannerQRCode_CFG_ASCII';
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_BINARY] = 'ScannerQRCode_CFG_BINARY';
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_NUM] = 'ScannerQRCode_CFG_NUM';
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_MIN_LEN] = 'ScannerQRCode_CFG_MIN_LEN';
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_MAX_LEN] = 'ScannerQRCode_CFG_MAX_LEN';
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_UNCERTAINTY] = 'ScannerQRCode_CFG_UNCERTAINTY';
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_POSITION] = 'ScannerQRCode_CFG_POSITION';
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_TEST_INVERTED] = 'ScannerQRCode_CFG_TEST_INVERTED';
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_X_DENSITY] = 'ScannerQRCode_CFG_X_DENSITY';
ScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_Y_DENSITY] = 'ScannerQRCode_CFG_Y_DENSITY';
/** @enum {number} */
const ScannerQRCodeOrientation = {
    ScannerQRCode_ORIENT_UNKNOWN: -1,
    ScannerQRCode_ORIENT_UP: 0,
    ScannerQRCode_ORIENT_RIGHT: 1,
    ScannerQRCode_ORIENT_DOWN: 2,
    ScannerQRCode_ORIENT_LEFT: 3,
};
ScannerQRCodeOrientation[ScannerQRCodeOrientation.ScannerQRCode_ORIENT_UNKNOWN] = 'ScannerQRCode_ORIENT_UNKNOWN';
ScannerQRCodeOrientation[ScannerQRCodeOrientation.ScannerQRCode_ORIENT_UP] = 'ScannerQRCode_ORIENT_UP';
ScannerQRCodeOrientation[ScannerQRCodeOrientation.ScannerQRCode_ORIENT_RIGHT] = 'ScannerQRCode_ORIENT_RIGHT';
ScannerQRCodeOrientation[ScannerQRCodeOrientation.ScannerQRCode_ORIENT_DOWN] = 'ScannerQRCode_ORIENT_DOWN';
ScannerQRCodeOrientation[ScannerQRCodeOrientation.ScannerQRCode_ORIENT_LEFT] = 'ScannerQRCode_ORIENT_LEFT';
class ScannerQRCodeTypePointer {
    /**
     * @param {?} ptr
     * @param {?} buf
     */
    constructor(ptr, buf) {
        this.ptr = ptr;
        this.ptr32 = ptr >> 2;
        this.buf = buf;
        this.HEAP8 = new Int8Array(buf);
        this.HEAPU32 = new Uint32Array(buf);
        this.HEAP32 = new Int32Array(buf);
    }
}
class ScannerQRCodeSymbolPtr extends ScannerQRCodeTypePointer {
    /**
     * @return {?}
     */
    get type() {
        return (/** @type {?} */ (this.HEAPU32[this.ptr32]));
    }
    /**
     * @return {?}
     */
    get data() {
        /** @type {?} */
        const len = this.HEAPU32[this.ptr32 + 4];
        /** @type {?} */
        const ptr = this.HEAPU32[this.ptr32 + 5];
        return Int8Array.from(this.HEAP8.subarray(ptr, ptr + len));
    }
    /**
     * @return {?}
     */
    get points() {
        /** @type {?} */
        const len = this.HEAPU32[this.ptr32 + 7];
        /** @type {?} */
        const ptr = this.HEAPU32[this.ptr32 + 8];
        /** @type {?} */
        const ptr32 = ptr >> 2;
        /** @type {?} */
        const res = [];
        for (let i = 0; i < len; ++i) {
            /** @type {?} */
            const x = this.HEAP32[ptr32 + i * 2];
            /** @type {?} */
            const y = this.HEAP32[ptr32 + i * 2 + 1];
            res.push((/** @type {?} */ ({ x, y })));
        }
        return res;
    }
    /**
     * @return {?}
     */
    get orientation() {
        return this.HEAP32[this.ptr32 + 9];
    }
    /**
     * @return {?}
     */
    get next() {
        /** @type {?} */
        const ptr = this.HEAPU32[this.ptr32 + 11];
        if (!ptr)
            return null;
        return new ScannerQRCodeSymbolPtr(ptr, this.buf);
    }
    /**
     * @return {?}
     */
    get time() {
        return this.HEAPU32[this.ptr32 + 13];
    }
    /**
     * @return {?}
     */
    get cacheCount() {
        return this.HEAP32[this.ptr32 + 14];
    }
    /**
     * @return {?}
     */
    get quality() {
        return this.HEAP32[this.ptr32 + 15];
    }
}
class SymbolSetPtr extends ScannerQRCodeTypePointer {
    /**
     * @return {?}
     */
    get head() {
        /** @type {?} */
        const ptr = this.HEAPU32[this.ptr32 + 2];
        if (!ptr)
            return null;
        return new ScannerQRCodeSymbolPtr(ptr, this.buf);
    }
}
class ScannerQRCodeResult {
    /**
     * @private
     * @param {?} ptr
     */
    constructor(ptr) {
        this.value = '';
        this.type = ptr.type;
        this.typeName = ScannerQRCodeSymbolType[this.type];
        this.data = ptr.data;
        this.points = ptr.points;
        this.orientation = ptr.orientation;
        this.time = ptr.time;
        this.cacheCount = ptr.cacheCount;
        this.quality = ptr.quality;
    }
    /**
     * @param {?} ptr
     * @param {?} buf
     * @return {?}
     */
    static createSymbolsFromPtr(ptr, buf) {
        if (ptr == 0)
            return [];
        /** @type {?} */
        const set = new SymbolSetPtr(ptr, buf);
        /** @type {?} */
        let symbol = set.head;
        /** @type {?} */
        const res = [];
        while (symbol !== null) {
            res.push(new ScannerQRCodeResult(symbol));
            symbol = symbol.next;
        }
        return res;
    }
    /**
     * @param {?=} encoding
     * @return {?}
     */
    decode(encoding) {
        /** @type {?} */
        const decoder = new TextDecoder(encoding);
        return decoder.decode(this.data);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxScannerQrcodeModule {
}
NgxScannerQrcodeModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NgxScannerQrcodeComponent],
                exports: [NgxScannerQrcodeComponent],
                providers: [NgxScannerQrcodeService],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgxScannerQrcodeService, NgxScannerQrcodeComponent, ScannerQRCodeSymbolType, ScannerQRCodeConfigType, ScannerQRCodeOrientation, ScannerQRCodeResult, NgxScannerQrcodeModule };

//# sourceMappingURL=ngx-scanner-qrcode.js.map