{"version":3,"file":"zxing-scanner.component.d.ts","sources":["zxing-scanner.component.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { ElementRef, EventEmitter, OnDestroy, OnInit } from '@angular/core';\nimport { BarcodeFormat, DecodeHintType, Exception, Result } from '@zxing/library';\nimport { BrowserMultiFormatContinuousReader } from './browser-multi-format-continuous-reader';\nexport declare class ZXingScannerComponent implements OnInit, OnDestroy {\n    /**\n     * Supported Hints map.\n     */\n    private _hints;\n    /**\n     * The ZXing code reader.\n     */\n    private _codeReader;\n    /**\n     * The device that should be used to scan things.\n     */\n    private _device;\n    /**\n     * The device that should be used to scan things.\n     */\n    private _enabled;\n    /**\n     *\n     */\n    private _isAutostarting;\n    /**\n     * Has `navigator` access.\n     */\n    private hasNavigator;\n    /**\n     * Says if some native API is supported.\n     */\n    private isMediaDevicesSupported;\n    /**\n     * If the user-agent allowed the use of the camera or not.\n     */\n    private hasPermission;\n    /**\n     * Unsubscribe to stop scanning.\n     */\n    private _scanSubscription?;\n    /**\n     * Reference to the preview element, should be the `video` tag.\n     */\n    previewElemRef: ElementRef<HTMLVideoElement>;\n    /**\n     * Enable or disable autofocus of the camera (might have an impact on performance)\n     */\n    autofocusEnabled: boolean;\n    /**\n     * Delay between attempts to decode (default is 500ms)\n     */\n    timeBetweenScans: number;\n    /**\n     * Delay between successful decode (default is 500ms)\n     */\n    delayBetweenScanSuccess: number;\n    /**\n     * Emits when and if the scanner is autostarted.\n     */\n    autostarted: EventEmitter<void>;\n    /**\n     * True during autostart and false after. It will be null if won't autostart at all.\n     */\n    autostarting: EventEmitter<boolean>;\n    /**\n     * If the scanner should autostart with the first available device.\n     */\n    autostart: boolean;\n    /**\n     * How the preview element shoud be fit inside the :host container.\n     */\n    previewFitMode: 'fill' | 'contain' | 'cover' | 'scale-down' | 'none';\n    /**\n     * Emitts events when the torch compatibility is changed.\n     */\n    torchCompatible: EventEmitter<boolean>;\n    /**\n     * Emitts events when a scan is successful performed, will inject the string value of the QR-code to the callback.\n     */\n    scanSuccess: EventEmitter<string>;\n    /**\n     * Emitts events when a scan fails without errors, usefull to know how much scan tries where made.\n     */\n    scanFailure: EventEmitter<Exception | undefined>;\n    /**\n     * Emitts events when a scan throws some error, will inject the error to the callback.\n     */\n    scanError: EventEmitter<Error>;\n    /**\n     * Emitts events when a scan is performed, will inject the Result value of the QR-code scan (if available) to the callback.\n     */\n    scanComplete: EventEmitter<Result>;\n    /**\n     * Emitts events when no cameras are found, will inject an exception (if available) to the callback.\n     */\n    camerasFound: EventEmitter<MediaDeviceInfo[]>;\n    /**\n     * Emitts events when no cameras are found, will inject an exception (if available) to the callback.\n     */\n    camerasNotFound: EventEmitter<any>;\n    /**\n     * Emitts events when the users answers for permission.\n     */\n    permissionResponse: EventEmitter<boolean>;\n    /**\n     * Emitts events when has devices status is update.\n     */\n    hasDevices: EventEmitter<boolean>;\n    private _ready;\n    private _devicePreStart;\n    /**\n     * Exposes the current code reader, so the user can use it's APIs.\n     */\n    get codeReader(): BrowserMultiFormatContinuousReader;\n    /**\n     * User device input\n     */\n    set device(device: MediaDeviceInfo | undefined);\n    /**\n     * Emits when the current device is changed.\n     */\n    deviceChange: EventEmitter<MediaDeviceInfo>;\n    /**\n     * User device acessor.\n     */\n    get device(): MediaDeviceInfo | undefined;\n    /**\n     * Returns all the registered formats.\n     */\n    get formats(): BarcodeFormat[];\n    /**\n     * Registers formats the scanner should support.\n     *\n     * @param input BarcodeFormat or case-insensitive string array.\n     */\n    set formats(input: BarcodeFormat[]);\n    /**\n     * Returns all the registered hints.\n     */\n    get hints(): Map<DecodeHintType, any>;\n    /**\n     * Does what it takes to set the hints.\n     */\n    set hints(hints: Map<DecodeHintType, any>);\n    /**\n     * Sets the desired constraints in all video tracks.\n     * @experimental\n     */\n    set videoConstraints(constraints: MediaTrackConstraints);\n    /**\n     *\n     */\n    set isAutostarting(state: boolean);\n    /**\n     *\n     */\n    get isAutostarting(): boolean;\n    /**\n     * Can turn on/off the device flashlight.\n     *\n     * @experimental Torch/Flash APIs are not stable in all browsers, it may be buggy!\n     */\n    set torch(onOff: boolean);\n    /**\n     * Starts and Stops the scanning.\n     */\n    set enable(enabled: boolean);\n    /**\n     * Tells if the scanner is enabled or not.\n     */\n    get enabled(): boolean;\n    /**\n     * If is `tryHarder` enabled.\n     */\n    get tryHarder(): boolean;\n    /**\n     * Enable/disable tryHarder hint.\n     */\n    set tryHarder(enable: boolean);\n    /**\n     * Constructor to build the object and do some DI.\n     */\n    constructor();\n    /**\n     * Gets and registers all cammeras.\n     */\n    askForPermission(): Promise<boolean>;\n    /**\n     *\n     */\n    getAnyVideoDevice(): Promise<MediaStream>;\n    /**\n     * Terminates a stream and it's tracks.\n     */\n    private terminateStream;\n    private init;\n    /**\n     * Initializes the component without starting the scanner.\n     */\n    private initAutostartOff;\n    /**\n     * Initializes the component and starts the scanner.\n     * Permissions are asked to accomplish that.\n     */\n    private initAutostartOn;\n    /**\n     * Checks if the given device is the current defined one.\n     */\n    isCurrentDevice(device?: MediaDeviceInfo): boolean;\n    /**\n     * Executes some actions before destroy the component.\n     */\n    ngOnDestroy(): void;\n    /**\n     *\n     */\n    ngOnInit(): void;\n    /**\n     * Stops the scanning, if any.\n     */\n    scanStop(): void;\n    /**\n     * Stops the scanning, if any.\n     */\n    scanStart(): void;\n    /**\n     * Stops old `codeReader` and starts scanning in a new one.\n     */\n    restart(): void;\n    /**\n     * Discovers and updates known video input devices.\n     */\n    updateVideoInputDevices(): Promise<MediaDeviceInfo[]>;\n    /**\n     * Starts the scanner with the back camera otherwise take the last\n     * available device.\n     */\n    private autostartScanner;\n    /**\n     * Dispatches the scan success event.\n     *\n     * @param result the scan result.\n     */\n    private dispatchScanSuccess;\n    /**\n     * Dispatches the scan failure event.\n     */\n    private dispatchScanFailure;\n    /**\n     * Dispatches the scan error event.\n     *\n     * @param error the error thing.\n     */\n    private dispatchScanError;\n    /**\n     * Dispatches the scan event.\n     *\n     * @param result the scan result.\n     */\n    private dispatchScanComplete;\n    /**\n     * Returns the filtered permission.\n     */\n    private handlePermissionException;\n    /**\n     * Returns a valid BarcodeFormat or fails.\n     */\n    private getBarcodeFormatOrFail;\n    /**\n     * Retorna um code reader, cria um se nenhume existe.\n     */\n    private getCodeReader;\n    /**\n     * Starts the continuous scanning for the given device.\n     *\n     * @param deviceId The deviceId from the device.\n     */\n    private scanFromDevice;\n    /**\n     * Handles decode errors.\n     */\n    private _onDecodeError;\n    /**\n     * Handles decode results.\n     */\n    private _onDecodeResult;\n    /**\n     * Stops the code reader and returns the previous selected device.\n     */\n    private _reset;\n    /**\n     * Resets the scanner and emits device change.\n     */\n    reset(): void;\n    /**\n     * Sets the current device.\n     */\n    private setDevice;\n    /**\n     * Sets the permission value and emmits the event.\n     */\n    private setPermission;\n}\n"]}